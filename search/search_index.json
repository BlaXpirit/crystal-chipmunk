{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"crystal-chipmunk # Crystal bindings to Chipmunk (2D rigid body physics library). Space Body Shapes Constraints Collisions Queries Vector math Debug draw","title":"crystal-chipmunk"},{"location":"index.html#crystal-chipmunk","text":"Crystal bindings to Chipmunk (2D rigid body physics library). Space Body Shapes Constraints Collisions Queries Vector math Debug draw","title":"crystal-chipmunk"},{"location":"body.html","text":"class CP::Body inherits Reference # Chipmunk's rigid body type. Rigid bodies hold the physical properties of an object like its mass, and position and velocity of its center of gravity. They don't have an shape on their own. They are given a shape by creating collision shapes ( Shape ) that point to the body. Use forces to modify the rigid bodies if possible. This is likely to be the most stable. Modifying a body's velocity shouldn't necessarily be avoided, but applying large changes can cause strange results in the simulation. Experiment freely, but be warned. Don't modify a body's position every step unless you really know what you are doing. Otherwise you're likely to get the position/velocity badly out of sync. Class methods # .new ( mass : Number = 0 , moment : Number = 0 ) # Create a new dynamic Body . Guessing the mass for a body is usually fine, but guessing a moment of inertia can lead to a very poor simulation so it's recommended to use Chipmunk's moment calculations to estimate the moment for you. There are two ways to set up a dynamic body. The easiest option is to create a body with a mass and moment of 0, and set the mass or density of each collision shape added to the body. Chipmunk will automatically calculate the mass, moment of inertia, and center of gravity for you. This is probably preferred in most cases. The other option is to set the mass of the body when it's created, and leave the mass of the shapes added to it as 0.0. This approach is more flexible, but is not as easy to use. Don't set the mass of both the body and the shapes. If you do so, it will recalculate and overwite your custom mass value when the shapes are added to the body. [ View source ] .new_kinematic : self # Create a Body , and set it as a kinematic body. [ View source ] .new_static : self # Create a Body , and set it as a static body. [ View source ] Methods # #activate # Wake up a sleeping or idle body. [ View source ] #activate_static ( filter : Shape? ) # Wake up any sleeping or idle bodies touching a static body. [ View source ] #angle : Float64 # Rotation of the body in radians. When changing the rotation you may also want to call Space.reindex_shapes_for(body) to update the collision detection information for the attached shapes if you plan to make any queries against the space. A body rotates around its center of gravity, not its position. [ View source ] #angle= ( angle : Number ) # [ View source ] #angular_velocity : Float64 # The angular velocity of the body in radians per second. [ View source ] #angular_velocity= ( angular_velocity : Number ) # [ View source ] #apply_force_at_local_point ( force : Vect , point : Vect ) # Apply a force to a body. Both the force and point are expressed in body local coordinates. [ View source ] #apply_force_at_world_point ( force : Vect , point : Vect ) # Apply a force to a body. Both the force and point are expressed in world coordinates. [ View source ] #apply_impulse_at_local_point ( impulse : Vect , point : Vect ) # Apply an impulse to a body. Both the impulse and point are expressed in body local coordinates. [ View source ] #apply_impulse_at_world_point ( impulse : Vect , point : Vect ) # Apply an impulse to a body. Both the impulse and point are expressed in world coordinates. An impulse is a very large force applied over a very short period of time. Some examples are a ball hitting a wall or cannon firing. Chipmunk treats impulses as if they occur instantaneously by adding directly to the velocity of an object. Both impulses and forces are affected the mass of an object. Doubling the mass of the object will halve the effect. [ View source ] #arbiters : Array ( Arbiter ) # Get each arbiter associated with this body. #center_of_gravity : Vect # The offset of the center of gravity in body local coordinates. The default value is (0, 0), meaning the center of gravity is the same as the position of the body. [ View source ] #center_of_gravity= ( center_of_gravity : Vect ) # [ View source ] #constraints : Array ( Constraint ) # Get each constraint associated with this body. #each_arbiter ( & block : Arbiter -> ) # Get each arbiter associated with this body. #each_constraint ( & block : Constraint -> ) # Get each constraint associated with this body. #each_shape ( & block : Shape -> ) # Get each shape associated with this body. #force : Vect # Force applied to the center of gravity of the body. This value is reset for every time step. [ View source ] #force= ( force : Vect ) # [ View source ] #kinetic_energy : Float64 # Get the amount of kinetic energy contained by the body. [ View source ] #local_to_world ( point : Vect ) : Vect # Convert body relative/local coordinates to absolute/world coordinates. [ View source ] #mass : Float64 # The mass of the body. [ View source ] #mass= ( mass : Number ) # [ View source ] #moment : Float64 # The moment of inertia of the body. The moment is like the rotational mass of a body. [ View source ] #moment= ( moment : Number ) # [ View source ] #position : Vect # The position of the body. When changing the position you may also want to call Space#reindex_shapes_for(body) to update the collision detection information for the attached shapes if you plan to make any queries against the space. [ View source ] #position= ( position : Vect ) # [ View source ] #rotation : Vect # Get the rotation vector of the body. (The x basis vector of its transform.) [ View source ] #shapes : Array ( Shape ) # Get each shape associated with this body. #sleep # Force a body to fall asleep immediately. [ View source ] #sleep_with_group ( group : Body ) # Force a body to fall asleep immediately along with other bodies in a group. When objects in Chipmunk sleep, they sleep as a group of all objects that are touching or jointed together. When an object is woken up, all of the objects in its group are woken up. sleep_with_group allows you group sleeping objects together. If you pass a sleeping body for group, body will be awoken when group is awoken. You can use this to initialize levels and start stacks of objects in a pre-sleeping state. [ View source ] #sleeping? : Bool # Returns true if the body is sleeping. [ View source ] #space : Space? # Get the space this body is added to. [ View source ] #torque : Float64 # The torque applied to the body. This value is reset for every time step. [ View source ] #torque= ( torque : Number ) # [ View source ] #type : Type # The type of the body. When changing a body to a dynamic body, the mass and moment of inertia are recalculated from the shapes added to the body. Custom calculated moments of inertia are not preseved when changing types. This function cannot be called directly in a collision callback. [ View source ] #type= ( type : Type ) # [ View source ] #update_position ( dt : Number ) # Called each time step to update a body's position (can be overridden in a subclass). Updates the position of the body using Euler integration. It's not generally recommended to override this unless you call super . [ View source ] #update_velocity ( gravity : Vect , damping : Number , dt : Number ) # Called each time step to update a body's velocity (can be overridden in a subclass). Updates the velocity of the body using Euler integration. [ View source ] #velocity : Vect # Linear velocity of the center of gravity of the body. [ View source ] #velocity= ( velocity : Vect ) # [ View source ] #velocity_at_local_point ( point : Vect ) : Vect # Get the velocity on a body (in world units) at a point on the body in local coordinates. [ View source ] #velocity_at_world_point ( point : Vect ) : Vect # Get the velocity on a body (in world units) at a point on the body in world coordinates. It's often useful to know the absolute velocity of a point on the surface of a body since the angular velocity affects everything except the center of gravity. [ View source ] #world_to_local ( point : Vect ) : Vect # Convert body absolute/world coordinates to relative/local coordinates. [ View source ] enum CP::Body::Type # Members # DYNAMIC # A dynamic body is one that is affected by gravity, forces, and collisions. This is the default body type. KINEMATIC # A kinematic body is an infinite mass, user controlled body that is not affected by gravity, forces or collisions. Instead the body only moves based on its velocity. Dynamic bodies collide normally with kinematic bodies, though the kinematic body will be unaffected. Collisions between two kinematic bodies, or a kinematic body and a static body produce collision callbacks, but no collision response. STATIC # A static body is a body that never (or rarely) moves. If you move a static body, you must call one of the Space reindex functions. Chipmunk uses this information to optimize the collision detection. Static bodies do not produce collision callbacks when colliding with other static bodies. Methods # #dynamic? # [ View source ] #kinematic? # [ View source ] #static? # [ View source ]","title":"Body"},{"location":"body.html#CP::Body","text":"Chipmunk's rigid body type. Rigid bodies hold the physical properties of an object like its mass, and position and velocity of its center of gravity. They don't have an shape on their own. They are given a shape by creating collision shapes ( Shape ) that point to the body. Use forces to modify the rigid bodies if possible. This is likely to be the most stable. Modifying a body's velocity shouldn't necessarily be avoided, but applying large changes can cause strange results in the simulation. Experiment freely, but be warned. Don't modify a body's position every step unless you really know what you are doing. Otherwise you're likely to get the position/velocity badly out of sync.","title":"Body"},{"location":"body.html#class-methods","text":"","title":"Class methods"},{"location":"body.html#CP::Body.new(mass,moment)","text":"Create a new dynamic Body . Guessing the mass for a body is usually fine, but guessing a moment of inertia can lead to a very poor simulation so it's recommended to use Chipmunk's moment calculations to estimate the moment for you. There are two ways to set up a dynamic body. The easiest option is to create a body with a mass and moment of 0, and set the mass or density of each collision shape added to the body. Chipmunk will automatically calculate the mass, moment of inertia, and center of gravity for you. This is probably preferred in most cases. The other option is to set the mass of the body when it's created, and leave the mass of the shapes added to it as 0.0. This approach is more flexible, but is not as easy to use. Don't set the mass of both the body and the shapes. If you do so, it will recalculate and overwite your custom mass value when the shapes are added to the body. [ View source ]","title":".new"},{"location":"body.html#CP::Body.new_kinematic()","text":"Create a Body , and set it as a kinematic body. [ View source ]","title":".new_kinematic"},{"location":"body.html#CP::Body.new_static()","text":"Create a Body , and set it as a static body. [ View source ]","title":".new_static"},{"location":"body.html#methods","text":"","title":"Methods"},{"location":"body.html#CP::Body#activate()","text":"Wake up a sleeping or idle body. [ View source ]","title":"#activate"},{"location":"body.html#CP::Body#activate_static(filter)","text":"Wake up any sleeping or idle bodies touching a static body. [ View source ]","title":"#activate_static"},{"location":"body.html#CP::Body#angle()","text":"Rotation of the body in radians. When changing the rotation you may also want to call Space.reindex_shapes_for(body) to update the collision detection information for the attached shapes if you plan to make any queries against the space. A body rotates around its center of gravity, not its position. [ View source ]","title":"#angle"},{"location":"body.html#CP::Body#angle=(angle)","text":"[ View source ]","title":"#angle="},{"location":"body.html#CP::Body#angular_velocity()","text":"The angular velocity of the body in radians per second. [ View source ]","title":"#angular_velocity"},{"location":"body.html#CP::Body#angular_velocity=(angular_velocity)","text":"[ View source ]","title":"#angular_velocity="},{"location":"body.html#CP::Body#apply_force_at_local_point(force,point)","text":"Apply a force to a body. Both the force and point are expressed in body local coordinates. [ View source ]","title":"#apply_force_at_local_point"},{"location":"body.html#CP::Body#apply_force_at_world_point(force,point)","text":"Apply a force to a body. Both the force and point are expressed in world coordinates. [ View source ]","title":"#apply_force_at_world_point"},{"location":"body.html#CP::Body#apply_impulse_at_local_point(impulse,point)","text":"Apply an impulse to a body. Both the impulse and point are expressed in body local coordinates. [ View source ]","title":"#apply_impulse_at_local_point"},{"location":"body.html#CP::Body#apply_impulse_at_world_point(impulse,point)","text":"Apply an impulse to a body. Both the impulse and point are expressed in world coordinates. An impulse is a very large force applied over a very short period of time. Some examples are a ball hitting a wall or cannon firing. Chipmunk treats impulses as if they occur instantaneously by adding directly to the velocity of an object. Both impulses and forces are affected the mass of an object. Doubling the mass of the object will halve the effect. [ View source ]","title":"#apply_impulse_at_world_point"},{"location":"body.html#CP::Body#arbiters()","text":"Get each arbiter associated with this body.","title":"#arbiters"},{"location":"body.html#CP::Body#center_of_gravity()","text":"The offset of the center of gravity in body local coordinates. The default value is (0, 0), meaning the center of gravity is the same as the position of the body. [ View source ]","title":"#center_of_gravity"},{"location":"body.html#CP::Body#center_of_gravity=(center_of_gravity)","text":"[ View source ]","title":"#center_of_gravity="},{"location":"body.html#CP::Body#constraints()","text":"Get each constraint associated with this body.","title":"#constraints"},{"location":"body.html#CP::Body#each_arbiter(&)","text":"Get each arbiter associated with this body.","title":"#each_arbiter"},{"location":"body.html#CP::Body#each_constraint(&)","text":"Get each constraint associated with this body.","title":"#each_constraint"},{"location":"body.html#CP::Body#each_shape(&)","text":"Get each shape associated with this body.","title":"#each_shape"},{"location":"body.html#CP::Body#force()","text":"Force applied to the center of gravity of the body. This value is reset for every time step. [ View source ]","title":"#force"},{"location":"body.html#CP::Body#force=(force)","text":"[ View source ]","title":"#force="},{"location":"body.html#CP::Body#kinetic_energy()","text":"Get the amount of kinetic energy contained by the body. [ View source ]","title":"#kinetic_energy"},{"location":"body.html#CP::Body#local_to_world(point)","text":"Convert body relative/local coordinates to absolute/world coordinates. [ View source ]","title":"#local_to_world"},{"location":"body.html#CP::Body#mass()","text":"The mass of the body. [ View source ]","title":"#mass"},{"location":"body.html#CP::Body#mass=(mass)","text":"[ View source ]","title":"#mass="},{"location":"body.html#CP::Body#moment()","text":"The moment of inertia of the body. The moment is like the rotational mass of a body. [ View source ]","title":"#moment"},{"location":"body.html#CP::Body#moment=(moment)","text":"[ View source ]","title":"#moment="},{"location":"body.html#CP::Body#position()","text":"The position of the body. When changing the position you may also want to call Space#reindex_shapes_for(body) to update the collision detection information for the attached shapes if you plan to make any queries against the space. [ View source ]","title":"#position"},{"location":"body.html#CP::Body#position=(position)","text":"[ View source ]","title":"#position="},{"location":"body.html#CP::Body#rotation()","text":"Get the rotation vector of the body. (The x basis vector of its transform.) [ View source ]","title":"#rotation"},{"location":"body.html#CP::Body#shapes()","text":"Get each shape associated with this body.","title":"#shapes"},{"location":"body.html#CP::Body#sleep()","text":"Force a body to fall asleep immediately. [ View source ]","title":"#sleep"},{"location":"body.html#CP::Body#sleep_with_group(group)","text":"Force a body to fall asleep immediately along with other bodies in a group. When objects in Chipmunk sleep, they sleep as a group of all objects that are touching or jointed together. When an object is woken up, all of the objects in its group are woken up. sleep_with_group allows you group sleeping objects together. If you pass a sleeping body for group, body will be awoken when group is awoken. You can use this to initialize levels and start stacks of objects in a pre-sleeping state. [ View source ]","title":"#sleep_with_group"},{"location":"body.html#CP::Body#sleeping?()","text":"Returns true if the body is sleeping. [ View source ]","title":"#sleeping?"},{"location":"body.html#CP::Body#space()","text":"Get the space this body is added to. [ View source ]","title":"#space"},{"location":"body.html#CP::Body#torque()","text":"The torque applied to the body. This value is reset for every time step. [ View source ]","title":"#torque"},{"location":"body.html#CP::Body#torque=(torque)","text":"[ View source ]","title":"#torque="},{"location":"body.html#CP::Body#type()","text":"The type of the body. When changing a body to a dynamic body, the mass and moment of inertia are recalculated from the shapes added to the body. Custom calculated moments of inertia are not preseved when changing types. This function cannot be called directly in a collision callback. [ View source ]","title":"#type"},{"location":"body.html#CP::Body#type=(type)","text":"[ View source ]","title":"#type="},{"location":"body.html#CP::Body#update_position(dt)","text":"Called each time step to update a body's position (can be overridden in a subclass). Updates the position of the body using Euler integration. It's not generally recommended to override this unless you call super . [ View source ]","title":"#update_position"},{"location":"body.html#CP::Body#update_velocity(gravity,damping,dt)","text":"Called each time step to update a body's velocity (can be overridden in a subclass). Updates the velocity of the body using Euler integration. [ View source ]","title":"#update_velocity"},{"location":"body.html#CP::Body#velocity()","text":"Linear velocity of the center of gravity of the body. [ View source ]","title":"#velocity"},{"location":"body.html#CP::Body#velocity=(velocity)","text":"[ View source ]","title":"#velocity="},{"location":"body.html#CP::Body#velocity_at_local_point(point)","text":"Get the velocity on a body (in world units) at a point on the body in local coordinates. [ View source ]","title":"#velocity_at_local_point"},{"location":"body.html#CP::Body#velocity_at_world_point(point)","text":"Get the velocity on a body (in world units) at a point on the body in world coordinates. It's often useful to know the absolute velocity of a point on the surface of a body since the angular velocity affects everything except the center of gravity. [ View source ]","title":"#velocity_at_world_point"},{"location":"body.html#CP::Body#world_to_local(point)","text":"Convert body absolute/world coordinates to relative/local coordinates. [ View source ]","title":"#world_to_local"},{"location":"body.html#CP::Body::Type","text":"","title":"Type"},{"location":"body.html#members","text":"","title":"Members"},{"location":"body.html#CP::Body::Type::DYNAMIC","text":"A dynamic body is one that is affected by gravity, forces, and collisions. This is the default body type.","title":"DYNAMIC"},{"location":"body.html#CP::Body::Type::KINEMATIC","text":"A kinematic body is an infinite mass, user controlled body that is not affected by gravity, forces or collisions. Instead the body only moves based on its velocity. Dynamic bodies collide normally with kinematic bodies, though the kinematic body will be unaffected. Collisions between two kinematic bodies, or a kinematic body and a static body produce collision callbacks, but no collision response.","title":"KINEMATIC"},{"location":"body.html#CP::Body::Type::STATIC","text":"A static body is a body that never (or rarely) moves. If you move a static body, you must call one of the Space reindex functions. Chipmunk uses this information to optimize the collision detection. Static bodies do not produce collision callbacks when colliding with other static bodies.","title":"STATIC"},{"location":"body.html#methods_1","text":"","title":"Methods"},{"location":"body.html#CP::Body::Type#dynamic?()","text":"[ View source ]","title":"#dynamic?"},{"location":"body.html#CP::Body::Type#kinematic?()","text":"[ View source ]","title":"#kinematic?"},{"location":"body.html#CP::Body::Type#static?()","text":"[ View source ]","title":"#static?"},{"location":"collisions.html","text":"struct CP::Arbiter inherits Struct # The Arbiter object encapsulates a pair of colliding shapes and all of the data about their collision. They are created when a collision starts, and persist until those shapes are no longer colliding. Warning: Because arbiters are handled by the space you should never hold on to an arbiter as you don't know when it will be destroyed! Use them within the callback where they are given to you and then forget about them or copy out the information you need from them. Methods # #bodies : Tuple ( Body , Body ) # Return the colliding bodies involved for this arbiter. The order of the collision_type the bodies are associated with values will match the order set when the collision handler was registered. [ View source ] #call_wildcard_begin_a ( space : Space ) : Bool # If you want a custom callback to invoke the wildcard callback for the first collision type, you must call this function explicitly. You must decide how to handle the wildcard's return value since it may disagree with the other wildcard handler's return value or your own. [ View source ] #call_wildcard_begin_b ( space : Space ) : Bool # If you want a custom callback to invoke the wildcard callback for the second collision type, you must call this function explicitly. You must decide how to handle the wildcard's return value since it may disagree with the other wildcard handler's return value or your own. [ View source ] #call_wildcard_post_solve_a ( space : Space ) # If you want a custom callback to invoke the wildcard callback for the first collision type, you must call this function explicitly. [ View source ] #call_wildcard_post_solve_b ( space : Space ) # If you want a custom callback to invoke the wildcard callback for the second collision type, you must call this function explicitly. [ View source ] #call_wildcard_pre_solve_a ( space : Space ) : Bool # If you want a custom callback to invoke the wildcard callback for the first collision type, you must call this function explicitly. You must decide how to handle the wildcard's return value since it may disagree with the other wildcard handler's return value or your own. [ View source ] #call_wildcard_pre_solve_b ( space : Space ) : Bool # If you want a custom callback to invoke the wildcard callback for the second collision type, you must call this function explicitly. You must decide how to handle the wildcard's return value since it may disagree with the other wildcard handler's return value or your own. [ View source ] #call_wildcard_separate_a ( space : Space ) # If you want a custom callback to invoke the wildcard callback for the first collision type, you must call this function explicitly. [ View source ] #call_wildcard_separate_b ( space : Space ) # If you want a custom callback to invoke the wildcard callback for the second collision type, you must call this function explicitly. [ View source ] #contact_point_set : ContactPointSet # Return a contact set from an arbiter. [ View source ] #contact_point_set= ( contact_point_set : ContactPointSet ) # Replace the contact point set for an arbiter. This can be a very powerful feature, but use it with caution! [ View source ] #count : Int32 # Get the number of contact points for this arbiter. [ View source ] #data : Pointer ( Void ) # The user data pointer associated with this pair of colliding objects. [ View source ] #data= ( data ) # [ View source ] #depth ( i : Int ) : Float64 # Get the depth of the i -th contact point. [ View source ] #first_contact? : Bool # Returns true if this is the first step a pair of objects started colliding. This can be useful for sound effects for instance. If it's the first frame for a certain collision, check the energy of the collision in a post_step() callback and use that to determine the volume of a sound effect to play. [ View source ] #friction : Float64 # The friction coefficient that will be applied to the pair of colliding objects. Setting the value in a pre_solve() callback will override the value calculated by the space. The default calculation multiplies the friction of the two shapes together. [ View source ] #friction= ( friction : Number ) # [ View source ] #ignore : Bool # Mark a collision pair to be ignored until the two objects separate. Pre-solve and post-solve callbacks will not be called, but the separate callback will be called. [ View source ] #normal : Vect # Get the normal of the collision. [ View source ] #point_a ( i : Int ) : Vect # Get the position of the i -th contact point on the surface of the first shape. [ View source ] #point_b ( i : Int ) : Vect # Get the position of the i -th contact point on the surface of the second shape. [ View source ] #removal? : Bool # Returns true during a separate() callback if the callback was invoked due to an object removal. [ View source ] #restitution : Float64 # The restitution (elasticity) that will be applied to the pair of colliding objects. Setting the value in a pre_solve() callback will override the value calculated by the space. The default calculation multiplies the elasticity of the two shapes together. [ View source ] #restitution= ( restitution : Number ) # [ View source ] #shapes : Tuple ( Shape , Shape ) # Return the colliding shapes involved for this arbiter. The order of their collision_type values will match the order set when the collision handler was registered. [ View source ] #surface_velocity : Vect # The relative surface velocity of the two shapes in contact. Setting the value in a pre_solve() callback will override the value calculated by the space. the default calculation subtracts the surface velocity of the second shape from the first and then projects that onto the tangent of the collision. This is so that only friction is affected by default calculation. Using a custom calculation, you can make something that responds like a pinball bumper, or where the surface velocity is dependent on the location of the contact point. [ View source ] #surface_velocity= ( vr : Vect ) # [ View source ] #total_impulse : Vect # Calculate the total impulse including the friction that was applied by this arbiter. This function should only be called from a post-solve, post-step or each_arbiter callback. [ View source ] #total_ke : Float64 # Calculate the amount of energy lost in a collision including static, but not dynamic friction. This function should only be called from a post-solve, post-step or each_arbiter callback. [ View source ] class CP::CollisionHandler inherits Reference # Defines callbacks to configure custom collision handling. Collision handlers have a pair of types; when a collision occurs between two shapes that have these types, the collision handler functions are triggered. Shapes tagged as sensors ( Shape#sensor? == true ) never generate collisions that get processed, so collisions between sensors shapes and other shapes will never call the post_solve callback. They still generate begin , and separate callbacks, and the pre_solve callback is also called every frame even though there is no collision response. pre_solve callbacks are called before the sleeping algorithm runs. If an object falls asleep, its post_solve callback won't be called until it's reawoken. Methods # #begin ( arbiter : Arbiter , space : Space ) : Bool # This function is called when two shapes with types that match this collision handler begin colliding. Returning false from a begin callback causes the collision to be ignored until the the separate callback is called when the objects stop colliding. [ View source ] #post_solve ( arbiter : Arbiter , space : Space ) # This function is called each step when two shapes with types that match this collision handler are colliding. It's called after the collision solver runs, so you can retrieve the collision impulse or kinetic energy if you want to use it to calculate sound volumes or damage amounts. [ View source ] #pre_solve ( arbiter : Arbiter , space : Space ) : Bool # This function is called each step when two shapes with types that match this collision handler are colliding. It's called before the collision solver runs so that you can affect a collision's outcome (by editing Arbiter#friction , Arbiter#restitution , Arbiter#surface_velocity ). Returning false from a pre-step callback causes the collision to be ignored until the next step. [ View source ] #separate ( arbiter : Arbiter , space : Space ) # This function is called when two shapes with types that match this collision handler stop colliding. To ensure that begin / separate are always called in balanced pairs, it will also be called when removing a shape while it's in contact with something or when deallocating the space. [ View source ] #type_a : UInt64 # Collision type identifier of the first shape that this handler recognizes. In the collision handler callback, the shape with this type will be the first argument. [ View source ] #type_b : UInt64 # Collision type identifier of the second shape that this handler recognizes. In the collision handler callback, the shape with this type will be the second argument. [ View source ] alias CP::CollisionHandler::CollisionType # Alias definition # UInt64 struct CP::ContactPointSet inherits Struct # A struct that wraps up the important collision data for an arbiter. Class methods # .new ( points : Slice ( ContactPoint ), normal : Vect ) # [ View source ] Methods # #count : Int32 # The number of contact points in the set. [ View source ] #normal : Vect # The normal of the collision. [ View source ] #points : Slice ( ContactPoint ) # The contact points (at most 2). [ View source ] struct CP::ContactPointSet::ContactPoint inherits Struct # Contains information about a contact point. Class methods # .new ( point_a : Vect , point_b : Vect , distance : Number ) # [ View source ] Methods # #distance : Float64 # Penetration distance of the two shapes. Overlapping means it will be negative. This value is calculated as (point2 - point1).dot(normal) and is ignored by Arbiter#contact_point_set= . [ View source ] #point_a : Vect # The position of the contact on the surface of the first shape. [ View source ] #point_b : Vect # The position of the contact on the surface of the second shape. [ View source ]","title":"Collisions"},{"location":"collisions.html#CP::Arbiter","text":"The Arbiter object encapsulates a pair of colliding shapes and all of the data about their collision. They are created when a collision starts, and persist until those shapes are no longer colliding. Warning: Because arbiters are handled by the space you should never hold on to an arbiter as you don't know when it will be destroyed! Use them within the callback where they are given to you and then forget about them or copy out the information you need from them.","title":"Arbiter"},{"location":"collisions.html#methods","text":"","title":"Methods"},{"location":"collisions.html#CP::Arbiter#bodies()","text":"Return the colliding bodies involved for this arbiter. The order of the collision_type the bodies are associated with values will match the order set when the collision handler was registered. [ View source ]","title":"#bodies"},{"location":"collisions.html#CP::Arbiter#call_wildcard_begin_a(space)","text":"If you want a custom callback to invoke the wildcard callback for the first collision type, you must call this function explicitly. You must decide how to handle the wildcard's return value since it may disagree with the other wildcard handler's return value or your own. [ View source ]","title":"#call_wildcard_begin_a"},{"location":"collisions.html#CP::Arbiter#call_wildcard_begin_b(space)","text":"If you want a custom callback to invoke the wildcard callback for the second collision type, you must call this function explicitly. You must decide how to handle the wildcard's return value since it may disagree with the other wildcard handler's return value or your own. [ View source ]","title":"#call_wildcard_begin_b"},{"location":"collisions.html#CP::Arbiter#call_wildcard_post_solve_a(space)","text":"If you want a custom callback to invoke the wildcard callback for the first collision type, you must call this function explicitly. [ View source ]","title":"#call_wildcard_post_solve_a"},{"location":"collisions.html#CP::Arbiter#call_wildcard_post_solve_b(space)","text":"If you want a custom callback to invoke the wildcard callback for the second collision type, you must call this function explicitly. [ View source ]","title":"#call_wildcard_post_solve_b"},{"location":"collisions.html#CP::Arbiter#call_wildcard_pre_solve_a(space)","text":"If you want a custom callback to invoke the wildcard callback for the first collision type, you must call this function explicitly. You must decide how to handle the wildcard's return value since it may disagree with the other wildcard handler's return value or your own. [ View source ]","title":"#call_wildcard_pre_solve_a"},{"location":"collisions.html#CP::Arbiter#call_wildcard_pre_solve_b(space)","text":"If you want a custom callback to invoke the wildcard callback for the second collision type, you must call this function explicitly. You must decide how to handle the wildcard's return value since it may disagree with the other wildcard handler's return value or your own. [ View source ]","title":"#call_wildcard_pre_solve_b"},{"location":"collisions.html#CP::Arbiter#call_wildcard_separate_a(space)","text":"If you want a custom callback to invoke the wildcard callback for the first collision type, you must call this function explicitly. [ View source ]","title":"#call_wildcard_separate_a"},{"location":"collisions.html#CP::Arbiter#call_wildcard_separate_b(space)","text":"If you want a custom callback to invoke the wildcard callback for the second collision type, you must call this function explicitly. [ View source ]","title":"#call_wildcard_separate_b"},{"location":"collisions.html#CP::Arbiter#contact_point_set()","text":"Return a contact set from an arbiter. [ View source ]","title":"#contact_point_set"},{"location":"collisions.html#CP::Arbiter#contact_point_set=(contact_point_set)","text":"Replace the contact point set for an arbiter. This can be a very powerful feature, but use it with caution! [ View source ]","title":"#contact_point_set="},{"location":"collisions.html#CP::Arbiter#count()","text":"Get the number of contact points for this arbiter. [ View source ]","title":"#count"},{"location":"collisions.html#CP::Arbiter#data()","text":"The user data pointer associated with this pair of colliding objects. [ View source ]","title":"#data"},{"location":"collisions.html#CP::Arbiter#data=(data)","text":"[ View source ]","title":"#data="},{"location":"collisions.html#CP::Arbiter#depth(i)","text":"Get the depth of the i -th contact point. [ View source ]","title":"#depth"},{"location":"collisions.html#CP::Arbiter#first_contact?()","text":"Returns true if this is the first step a pair of objects started colliding. This can be useful for sound effects for instance. If it's the first frame for a certain collision, check the energy of the collision in a post_step() callback and use that to determine the volume of a sound effect to play. [ View source ]","title":"#first_contact?"},{"location":"collisions.html#CP::Arbiter#friction()","text":"The friction coefficient that will be applied to the pair of colliding objects. Setting the value in a pre_solve() callback will override the value calculated by the space. The default calculation multiplies the friction of the two shapes together. [ View source ]","title":"#friction"},{"location":"collisions.html#CP::Arbiter#friction=(friction)","text":"[ View source ]","title":"#friction="},{"location":"collisions.html#CP::Arbiter#ignore()","text":"Mark a collision pair to be ignored until the two objects separate. Pre-solve and post-solve callbacks will not be called, but the separate callback will be called. [ View source ]","title":"#ignore"},{"location":"collisions.html#CP::Arbiter#normal()","text":"Get the normal of the collision. [ View source ]","title":"#normal"},{"location":"collisions.html#CP::Arbiter#point_a(i)","text":"Get the position of the i -th contact point on the surface of the first shape. [ View source ]","title":"#point_a"},{"location":"collisions.html#CP::Arbiter#point_b(i)","text":"Get the position of the i -th contact point on the surface of the second shape. [ View source ]","title":"#point_b"},{"location":"collisions.html#CP::Arbiter#removal?()","text":"Returns true during a separate() callback if the callback was invoked due to an object removal. [ View source ]","title":"#removal?"},{"location":"collisions.html#CP::Arbiter#restitution()","text":"The restitution (elasticity) that will be applied to the pair of colliding objects. Setting the value in a pre_solve() callback will override the value calculated by the space. The default calculation multiplies the elasticity of the two shapes together. [ View source ]","title":"#restitution"},{"location":"collisions.html#CP::Arbiter#restitution=(restitution)","text":"[ View source ]","title":"#restitution="},{"location":"collisions.html#CP::Arbiter#shapes()","text":"Return the colliding shapes involved for this arbiter. The order of their collision_type values will match the order set when the collision handler was registered. [ View source ]","title":"#shapes"},{"location":"collisions.html#CP::Arbiter#surface_velocity()","text":"The relative surface velocity of the two shapes in contact. Setting the value in a pre_solve() callback will override the value calculated by the space. the default calculation subtracts the surface velocity of the second shape from the first and then projects that onto the tangent of the collision. This is so that only friction is affected by default calculation. Using a custom calculation, you can make something that responds like a pinball bumper, or where the surface velocity is dependent on the location of the contact point. [ View source ]","title":"#surface_velocity"},{"location":"collisions.html#CP::Arbiter#surface_velocity=(vr)","text":"[ View source ]","title":"#surface_velocity="},{"location":"collisions.html#CP::Arbiter#total_impulse()","text":"Calculate the total impulse including the friction that was applied by this arbiter. This function should only be called from a post-solve, post-step or each_arbiter callback. [ View source ]","title":"#total_impulse"},{"location":"collisions.html#CP::Arbiter#total_ke()","text":"Calculate the amount of energy lost in a collision including static, but not dynamic friction. This function should only be called from a post-solve, post-step or each_arbiter callback. [ View source ]","title":"#total_ke"},{"location":"collisions.html#CP::CollisionHandler","text":"Defines callbacks to configure custom collision handling. Collision handlers have a pair of types; when a collision occurs between two shapes that have these types, the collision handler functions are triggered. Shapes tagged as sensors ( Shape#sensor? == true ) never generate collisions that get processed, so collisions between sensors shapes and other shapes will never call the post_solve callback. They still generate begin , and separate callbacks, and the pre_solve callback is also called every frame even though there is no collision response. pre_solve callbacks are called before the sleeping algorithm runs. If an object falls asleep, its post_solve callback won't be called until it's reawoken.","title":"CollisionHandler"},{"location":"collisions.html#methods_1","text":"","title":"Methods"},{"location":"collisions.html#CP::CollisionHandler#begin(arbiter,space)","text":"This function is called when two shapes with types that match this collision handler begin colliding. Returning false from a begin callback causes the collision to be ignored until the the separate callback is called when the objects stop colliding. [ View source ]","title":"#begin"},{"location":"collisions.html#CP::CollisionHandler#post_solve(arbiter,space)","text":"This function is called each step when two shapes with types that match this collision handler are colliding. It's called after the collision solver runs, so you can retrieve the collision impulse or kinetic energy if you want to use it to calculate sound volumes or damage amounts. [ View source ]","title":"#post_solve"},{"location":"collisions.html#CP::CollisionHandler#pre_solve(arbiter,space)","text":"This function is called each step when two shapes with types that match this collision handler are colliding. It's called before the collision solver runs so that you can affect a collision's outcome (by editing Arbiter#friction , Arbiter#restitution , Arbiter#surface_velocity ). Returning false from a pre-step callback causes the collision to be ignored until the next step. [ View source ]","title":"#pre_solve"},{"location":"collisions.html#CP::CollisionHandler#separate(arbiter,space)","text":"This function is called when two shapes with types that match this collision handler stop colliding. To ensure that begin / separate are always called in balanced pairs, it will also be called when removing a shape while it's in contact with something or when deallocating the space. [ View source ]","title":"#separate"},{"location":"collisions.html#CP::CollisionHandler#type_a()","text":"Collision type identifier of the first shape that this handler recognizes. In the collision handler callback, the shape with this type will be the first argument. [ View source ]","title":"#type_a"},{"location":"collisions.html#CP::CollisionHandler#type_b()","text":"Collision type identifier of the second shape that this handler recognizes. In the collision handler callback, the shape with this type will be the second argument. [ View source ]","title":"#type_b"},{"location":"collisions.html#CP::CollisionHandler::CollisionType","text":"","title":"CollisionType"},{"location":"collisions.html#alias-definition","text":"UInt64","title":"Alias definition"},{"location":"collisions.html#CP::ContactPointSet","text":"A struct that wraps up the important collision data for an arbiter.","title":"ContactPointSet"},{"location":"collisions.html#class-methods","text":"","title":"Class methods"},{"location":"collisions.html#CP::ContactPointSet.new(points,normal)","text":"[ View source ]","title":".new"},{"location":"collisions.html#methods_2","text":"","title":"Methods"},{"location":"collisions.html#CP::ContactPointSet#count()","text":"The number of contact points in the set. [ View source ]","title":"#count"},{"location":"collisions.html#CP::ContactPointSet#normal()","text":"The normal of the collision. [ View source ]","title":"#normal"},{"location":"collisions.html#CP::ContactPointSet#points()","text":"The contact points (at most 2). [ View source ]","title":"#points"},{"location":"collisions.html#CP::ContactPointSet::ContactPoint","text":"Contains information about a contact point.","title":"ContactPoint"},{"location":"collisions.html#class-methods_1","text":"","title":"Class methods"},{"location":"collisions.html#CP::ContactPointSet::ContactPoint.new(point_a,point_b,distance)","text":"[ View source ]","title":".new"},{"location":"collisions.html#methods_3","text":"","title":"Methods"},{"location":"collisions.html#CP::ContactPointSet::ContactPoint#distance()","text":"Penetration distance of the two shapes. Overlapping means it will be negative. This value is calculated as (point2 - point1).dot(normal) and is ignored by Arbiter#contact_point_set= . [ View source ]","title":"#distance"},{"location":"collisions.html#CP::ContactPointSet::ContactPoint#point_a()","text":"The position of the contact on the surface of the first shape. [ View source ]","title":"#point_a"},{"location":"collisions.html#CP::ContactPointSet::ContactPoint#point_b()","text":"The position of the contact on the surface of the second shape. [ View source ]","title":"#point_b"},{"location":"constraints.html","text":"abstract class CP::Constraint inherits Reference # A constraint is something that describes how two bodies interact with each other (how they constrain each other). Constraints can be simple joints that allow bodies to pivot around each other like the bones in your body, or they can be more abstract like the gear joint or motors. Direct known subclasses # CP::Constraint::DampedRotarySpring CP::Constraint::DampedSpring CP::Constraint::GearJoint CP::Constraint::GrooveJoint CP::Constraint::PinJoint CP::Constraint::PivotJoint CP::Constraint::RatchetJoint CP::Constraint::RotaryLimitJoint CP::Constraint::SimpleMotor CP::Constraint::SlideJoint Methods # #bodies : Tuple ( Body , Body ) # Get the bodies the constraint is attached to. [ View source ] #body_a : Body # Get the first body the constraint is attached to. [ View source ] #body_b : Body # Get the second body the constraint is attached to. [ View source ] #collide_bodies= ( collide_bodies : Bool ) # [ View source ] #collide_bodies? : Bool # Are the two bodies connected by the constraint allowed to collide or not? (defaults to false) [ View source ] #error_bias : Float64 # Rate at which joint error is corrected. Defaults to (1.0 - 0.1) ** 60.0 meaning that it will correct 10% of the error every 1/60th of a second. [ View source ] #error_bias= ( error_bias : Number ) # [ View source ] #impulse : Float64 # Get the most recent impulse applied by this constraint. To convert this to a force, divide by the timestep passed to Space#step . You can use this to implement breakable joints to check if the force they attempted to apply exceeded a certain threshold. [ View source ] #max_bias : Float64 # The maximum rate at which joint error is corrected. (defaults to INFINITY) [ View source ] #max_bias= ( max_bias : Number ) # [ View source ] #max_force : Float64 # The maximum force that this constraint is allowed to use. (defaults to INFINITY) [ View source ] #max_force= ( max_force : Number ) # [ View source ] #post_solve ( space : Space ) # The post-solve method that is called before the solver runs (can be overridden in a subclass). [ View source ] #pre_solve ( space : Space ) # The pre-solve method that is called before the solver runs (can be overridden in a subclass). [ View source ] #space : Space? # Get the Space this constraint is added to. [ View source ] class CP::Constraint::DampedRotarySpring inherits CP::Constraint # Like a damped spring, but works in an angular fashion Class methods # .new ( a : Body , b : Body , rest_angle : Number , stiffness : Number , damping : Number ) # [ View source ] Methods # #damping : Float64 # How soft to make the damping of the spring. [ View source ] #damping= ( damping : Number ) # [ View source ] #rest_angle : Float64 # The relative angle in radians that the bodies want to have [ View source ] #rest_angle= ( rest_angle : Number ) # [ View source ] #spring_torque ( relative_angle : Float64 ) : Number # (can be overridden in a subclass) [ View source ] #stiffness : Float64 # The stiffness of the spring in force/distance. [ View source ] #stiffness= ( stiffness : Number ) # [ View source ] class CP::Constraint::DampedSpring inherits CP::Constraint # Class methods # .new ( a : Body , b : Body , anchor_a : Vect , anchor_b : Vect , rest_length : Number , stiffness : Number , damping : Number ) # Defined much like a slide joint. anchor_a : Anchor point a, relative to body a anchor_b : Anchor point b, relative to body b rest_length : The distance the spring wants to be at stiffness : The spring constant (Young's modulus) damping : How soft to make the damping of the spring [ View source ] Methods # #anchor_a : Vect # The location of the first anchor relative to the first body. [ View source ] #anchor_a= ( anchor_a : Vect ) # [ View source ] #anchor_b : Vect # The location of the second anchor relative to the second body. [ View source ] #anchor_b= ( anchor_b : Vect ) # [ View source ] #damping : Float64 # How soft to make the damping of the spring. [ View source ] #damping= ( damping : Number ) # [ View source ] #rest_length : Float64 # The distance the spring wants to be at. [ View source ] #rest_length= ( rest_length : Number ) # [ View source ] #spring_force ( dist : Float64 ) : Number # (can be overridden in a subclass) [ View source ] #stiffness : Float64 # The stiffness of the spring in force/distance. [ View source ] #stiffness= ( stiffness : Number ) # [ View source ] class CP::Constraint::GearJoint inherits CP::Constraint # Keeps the angular velocity ratio of a pair of bodies constant. Class methods # .new ( a : Body , b : Body , phase : Number , ratio : Number ) # [ View source ] Methods # #phase : Float64 # The phase offset of the gears. [ View source ] #phase= ( phase : Number ) # [ View source ] #ratio : Float64 # The angular distance of each ratchet. [ View source ] #ratio= ( ratio : Number ) # [ View source ] class CP::Constraint::GrooveJoint inherits CP::Constraint # Similar to a pivot joint, but one of the anchors is on a linear slide instead of being fixed. Class methods # .new ( a : Body , b : Body , groove_a : Vect , groove_b : Vect , anchor_b : Vect ) # The groove goes from groove_a to groove_b on body a , and the pivot is attached to anchor_b on body b . All coordinates are body local. [ View source ] Methods # #anchor_b : Vect # The location of the second anchor relative to the second body. [ View source ] #anchor_b= ( anchor_b : Vect ) # [ View source ] #groove_a : Vect # The first endpoint of the groove relative to the first body. [ View source ] #groove_a= ( groove_a : Vect ) # [ View source ] #groove_b : Vect # The second endpoint of the groove relative to the second body. [ View source ] #groove_b= ( groove_b : Vect ) # [ View source ] class CP::Constraint::PinJoint inherits CP::Constraint # Keeps the anchor points at a set distance from one another. Class methods # .new ( a : Body , b : Body , anchor_a : Vect , anchor_b : Vect ) # a and b are the two bodies to connect, and anchor_a and anchor_b arethe anchor points on those bodies. The distance between the two anchor points is measured when the joint is created. If you want to set a specific distance, use the setter function to override it. [ View source ] Methods # #anchor_a : Vect # The location of the first anchor relative to the first body. [ View source ] #anchor_a= ( anchor_a : Vect ) # [ View source ] #anchor_b : Vect # The location of the second anchor relative to the second body. [ View source ] #anchor_b= ( anchor_b : Vect ) # [ View source ] #dist : Float64 # The distance the joint will maintain between the two anchors. [ View source ] #dist= ( dist : Number ) # [ View source ] class CP::Constraint::PivotJoint inherits CP::Constraint # Allows two objects to pivot about a single point. Class methods # .new ( a : Body , b : Body , anchor_a : Vect , anchor_b : Vect ) # a and b are the two bodies to connect, and anchor_a and anchor_b are the points in local coordinates where the pivot is located. [ View source ] .new ( a : Body , b : Body , pivot : Vect ) : self # a and b are the two bodies to connect, and pivot is the point in world coordinates of the pivot. [ View source ] Methods # #anchor_a : Vect # The location of the first anchor relative to the first body. [ View source ] #anchor_a= ( anchor_a : Vect ) # [ View source ] #anchor_b : Vect # The location of the second anchor relative to the second body. [ View source ] #anchor_b= ( anchor_b : Vect ) # [ View source ] class CP::Constraint::RatchetJoint inherits CP::Constraint # Works like a socket wrench. Class methods # .new ( a : Body , b : Body , phase : Number , ratchet : Number ) # ratchet is the distance between \"clicks\", phase is the initial offset to use when deciding where the ratchet angles are. [ View source ] Methods # #angle : Float64 # The angle of the current ratchet tooth. [ View source ] #angle= ( angle : Number ) # [ View source ] #phase : Float64 # The phase offset of the ratchet. [ View source ] #phase= ( phase : Number ) # [ View source ] #ratchet : Float64 # The angular distance of each ratchet. [ View source ] #ratchet= ( ratchet : Number ) # [ View source ] class CP::Constraint::RotaryLimitJoint inherits CP::Constraint # Constrains the relative rotations of two bodies. Class methods # .new ( a : Body , b : Body , min : Number , max : Number ) # min and max are the angular limits in radians. It is implemented so that it's possible to for the range to be greater than a full revolution. [ View source ] Methods # #max : Float64 # The maximum distance the joint will maintain between the two anchors. [ View source ] #max= ( max : Number ) # [ View source ] #min : Float64 # The minimum distance the joint will maintain between the two anchors. [ View source ] #min= ( min : Number ) # [ View source ] class CP::Constraint::SimpleMotor inherits CP::Constraint # Keeps the relative angular velocity of a pair of bodies constant. Class methods # .new ( a : Body , b : Body , rate : Number ) # [ View source ] Methods # #rate : Float64 # The desired relative angular velocity of the motor. You will usually want to set a force (torque) maximum for motors as otherwise they will be able to apply a nearly infinite torque to keep the bodies moving. [ View source ] #rate= ( rate : Number ) # [ View source ] class CP::Constraint::SlideJoint inherits CP::Constraint # Like pin joints, but have a minimum and maximum distance. A chain could be modeled using this joint. It keeps the anchor points from getting too far apart, but will allow them to get closer together. Class methods # .new ( a : Body , b : Body , anchor_a : Vect , anchor_b : Vect , min : Number , max : Number ) # a and b are the two bodies to connect, anchor_a and anchor_b are the anchor points on those bodies, and min and max define the allowed distances of the anchor points. [ View source ] Methods # #anchor_a : Vect # The location of the first anchor relative to the first body. [ View source ] #anchor_a= ( anchor_a : Vect ) # [ View source ] #anchor_b : Vect # The location of the second anchor relative to the second body. [ View source ] #anchor_b= ( anchor_b : Vect ) # [ View source ] #max : Float64 # The maximum distance the joint will maintain between the two anchors. [ View source ] #max= ( max : Number ) # [ View source ] #min : Float64 # The minimum distance the joint will maintain between the two anchors. [ View source ] #min= ( min : Number ) # [ View source ]","title":"Constraints"},{"location":"constraints.html#CP::Constraint","text":"A constraint is something that describes how two bodies interact with each other (how they constrain each other). Constraints can be simple joints that allow bodies to pivot around each other like the bones in your body, or they can be more abstract like the gear joint or motors.","title":"Constraint"},{"location":"constraints.html#direct-known-subclasses","text":"CP::Constraint::DampedRotarySpring CP::Constraint::DampedSpring CP::Constraint::GearJoint CP::Constraint::GrooveJoint CP::Constraint::PinJoint CP::Constraint::PivotJoint CP::Constraint::RatchetJoint CP::Constraint::RotaryLimitJoint CP::Constraint::SimpleMotor CP::Constraint::SlideJoint","title":"Direct known subclasses"},{"location":"constraints.html#methods","text":"","title":"Methods"},{"location":"constraints.html#CP::Constraint#bodies()","text":"Get the bodies the constraint is attached to. [ View source ]","title":"#bodies"},{"location":"constraints.html#CP::Constraint#body_a()","text":"Get the first body the constraint is attached to. [ View source ]","title":"#body_a"},{"location":"constraints.html#CP::Constraint#body_b()","text":"Get the second body the constraint is attached to. [ View source ]","title":"#body_b"},{"location":"constraints.html#CP::Constraint#collide_bodies=(collide_bodies)","text":"[ View source ]","title":"#collide_bodies="},{"location":"constraints.html#CP::Constraint#collide_bodies?()","text":"Are the two bodies connected by the constraint allowed to collide or not? (defaults to false) [ View source ]","title":"#collide_bodies?"},{"location":"constraints.html#CP::Constraint#error_bias()","text":"Rate at which joint error is corrected. Defaults to (1.0 - 0.1) ** 60.0 meaning that it will correct 10% of the error every 1/60th of a second. [ View source ]","title":"#error_bias"},{"location":"constraints.html#CP::Constraint#error_bias=(error_bias)","text":"[ View source ]","title":"#error_bias="},{"location":"constraints.html#CP::Constraint#impulse()","text":"Get the most recent impulse applied by this constraint. To convert this to a force, divide by the timestep passed to Space#step . You can use this to implement breakable joints to check if the force they attempted to apply exceeded a certain threshold. [ View source ]","title":"#impulse"},{"location":"constraints.html#CP::Constraint#max_bias()","text":"The maximum rate at which joint error is corrected. (defaults to INFINITY) [ View source ]","title":"#max_bias"},{"location":"constraints.html#CP::Constraint#max_bias=(max_bias)","text":"[ View source ]","title":"#max_bias="},{"location":"constraints.html#CP::Constraint#max_force()","text":"The maximum force that this constraint is allowed to use. (defaults to INFINITY) [ View source ]","title":"#max_force"},{"location":"constraints.html#CP::Constraint#max_force=(max_force)","text":"[ View source ]","title":"#max_force="},{"location":"constraints.html#CP::Constraint#post_solve(space)","text":"The post-solve method that is called before the solver runs (can be overridden in a subclass). [ View source ]","title":"#post_solve"},{"location":"constraints.html#CP::Constraint#pre_solve(space)","text":"The pre-solve method that is called before the solver runs (can be overridden in a subclass). [ View source ]","title":"#pre_solve"},{"location":"constraints.html#CP::Constraint#space()","text":"Get the Space this constraint is added to. [ View source ]","title":"#space"},{"location":"constraints.html#CP::Constraint::DampedRotarySpring","text":"Like a damped spring, but works in an angular fashion","title":"DampedRotarySpring"},{"location":"constraints.html#class-methods","text":"","title":"Class methods"},{"location":"constraints.html#CP::Constraint::DampedRotarySpring.new(a,b,rest_angle,stiffness,damping)","text":"[ View source ]","title":".new"},{"location":"constraints.html#methods_1","text":"","title":"Methods"},{"location":"constraints.html#CP::Constraint::DampedRotarySpring#damping()","text":"How soft to make the damping of the spring. [ View source ]","title":"#damping"},{"location":"constraints.html#CP::Constraint::DampedRotarySpring#damping=(damping)","text":"[ View source ]","title":"#damping="},{"location":"constraints.html#CP::Constraint::DampedRotarySpring#rest_angle()","text":"The relative angle in radians that the bodies want to have [ View source ]","title":"#rest_angle"},{"location":"constraints.html#CP::Constraint::DampedRotarySpring#rest_angle=(rest_angle)","text":"[ View source ]","title":"#rest_angle="},{"location":"constraints.html#CP::Constraint::DampedRotarySpring#spring_torque(relative_angle)","text":"(can be overridden in a subclass) [ View source ]","title":"#spring_torque"},{"location":"constraints.html#CP::Constraint::DampedRotarySpring#stiffness()","text":"The stiffness of the spring in force/distance. [ View source ]","title":"#stiffness"},{"location":"constraints.html#CP::Constraint::DampedRotarySpring#stiffness=(stiffness)","text":"[ View source ]","title":"#stiffness="},{"location":"constraints.html#CP::Constraint::DampedSpring","text":"","title":"DampedSpring"},{"location":"constraints.html#class-methods_1","text":"","title":"Class methods"},{"location":"constraints.html#CP::Constraint::DampedSpring.new(a,b,anchor_a,anchor_b,rest_length,stiffness,damping)","text":"Defined much like a slide joint. anchor_a : Anchor point a, relative to body a anchor_b : Anchor point b, relative to body b rest_length : The distance the spring wants to be at stiffness : The spring constant (Young's modulus) damping : How soft to make the damping of the spring [ View source ]","title":".new"},{"location":"constraints.html#methods_2","text":"","title":"Methods"},{"location":"constraints.html#CP::Constraint::DampedSpring#anchor_a()","text":"The location of the first anchor relative to the first body. [ View source ]","title":"#anchor_a"},{"location":"constraints.html#CP::Constraint::DampedSpring#anchor_a=(anchor_a)","text":"[ View source ]","title":"#anchor_a="},{"location":"constraints.html#CP::Constraint::DampedSpring#anchor_b()","text":"The location of the second anchor relative to the second body. [ View source ]","title":"#anchor_b"},{"location":"constraints.html#CP::Constraint::DampedSpring#anchor_b=(anchor_b)","text":"[ View source ]","title":"#anchor_b="},{"location":"constraints.html#CP::Constraint::DampedSpring#damping()","text":"How soft to make the damping of the spring. [ View source ]","title":"#damping"},{"location":"constraints.html#CP::Constraint::DampedSpring#damping=(damping)","text":"[ View source ]","title":"#damping="},{"location":"constraints.html#CP::Constraint::DampedSpring#rest_length()","text":"The distance the spring wants to be at. [ View source ]","title":"#rest_length"},{"location":"constraints.html#CP::Constraint::DampedSpring#rest_length=(rest_length)","text":"[ View source ]","title":"#rest_length="},{"location":"constraints.html#CP::Constraint::DampedSpring#spring_force(dist)","text":"(can be overridden in a subclass) [ View source ]","title":"#spring_force"},{"location":"constraints.html#CP::Constraint::DampedSpring#stiffness()","text":"The stiffness of the spring in force/distance. [ View source ]","title":"#stiffness"},{"location":"constraints.html#CP::Constraint::DampedSpring#stiffness=(stiffness)","text":"[ View source ]","title":"#stiffness="},{"location":"constraints.html#CP::Constraint::GearJoint","text":"Keeps the angular velocity ratio of a pair of bodies constant.","title":"GearJoint"},{"location":"constraints.html#class-methods_2","text":"","title":"Class methods"},{"location":"constraints.html#CP::Constraint::GearJoint.new(a,b,phase,ratio)","text":"[ View source ]","title":".new"},{"location":"constraints.html#methods_3","text":"","title":"Methods"},{"location":"constraints.html#CP::Constraint::GearJoint#phase()","text":"The phase offset of the gears. [ View source ]","title":"#phase"},{"location":"constraints.html#CP::Constraint::GearJoint#phase=(phase)","text":"[ View source ]","title":"#phase="},{"location":"constraints.html#CP::Constraint::GearJoint#ratio()","text":"The angular distance of each ratchet. [ View source ]","title":"#ratio"},{"location":"constraints.html#CP::Constraint::GearJoint#ratio=(ratio)","text":"[ View source ]","title":"#ratio="},{"location":"constraints.html#CP::Constraint::GrooveJoint","text":"Similar to a pivot joint, but one of the anchors is on a linear slide instead of being fixed.","title":"GrooveJoint"},{"location":"constraints.html#class-methods_3","text":"","title":"Class methods"},{"location":"constraints.html#CP::Constraint::GrooveJoint.new(a,b,groove_a,groove_b,anchor_b)","text":"The groove goes from groove_a to groove_b on body a , and the pivot is attached to anchor_b on body b . All coordinates are body local. [ View source ]","title":".new"},{"location":"constraints.html#methods_4","text":"","title":"Methods"},{"location":"constraints.html#CP::Constraint::GrooveJoint#anchor_b()","text":"The location of the second anchor relative to the second body. [ View source ]","title":"#anchor_b"},{"location":"constraints.html#CP::Constraint::GrooveJoint#anchor_b=(anchor_b)","text":"[ View source ]","title":"#anchor_b="},{"location":"constraints.html#CP::Constraint::GrooveJoint#groove_a()","text":"The first endpoint of the groove relative to the first body. [ View source ]","title":"#groove_a"},{"location":"constraints.html#CP::Constraint::GrooveJoint#groove_a=(groove_a)","text":"[ View source ]","title":"#groove_a="},{"location":"constraints.html#CP::Constraint::GrooveJoint#groove_b()","text":"The second endpoint of the groove relative to the second body. [ View source ]","title":"#groove_b"},{"location":"constraints.html#CP::Constraint::GrooveJoint#groove_b=(groove_b)","text":"[ View source ]","title":"#groove_b="},{"location":"constraints.html#CP::Constraint::PinJoint","text":"Keeps the anchor points at a set distance from one another.","title":"PinJoint"},{"location":"constraints.html#class-methods_4","text":"","title":"Class methods"},{"location":"constraints.html#CP::Constraint::PinJoint.new(a,b,anchor_a,anchor_b)","text":"a and b are the two bodies to connect, and anchor_a and anchor_b arethe anchor points on those bodies. The distance between the two anchor points is measured when the joint is created. If you want to set a specific distance, use the setter function to override it. [ View source ]","title":".new"},{"location":"constraints.html#methods_5","text":"","title":"Methods"},{"location":"constraints.html#CP::Constraint::PinJoint#anchor_a()","text":"The location of the first anchor relative to the first body. [ View source ]","title":"#anchor_a"},{"location":"constraints.html#CP::Constraint::PinJoint#anchor_a=(anchor_a)","text":"[ View source ]","title":"#anchor_a="},{"location":"constraints.html#CP::Constraint::PinJoint#anchor_b()","text":"The location of the second anchor relative to the second body. [ View source ]","title":"#anchor_b"},{"location":"constraints.html#CP::Constraint::PinJoint#anchor_b=(anchor_b)","text":"[ View source ]","title":"#anchor_b="},{"location":"constraints.html#CP::Constraint::PinJoint#dist()","text":"The distance the joint will maintain between the two anchors. [ View source ]","title":"#dist"},{"location":"constraints.html#CP::Constraint::PinJoint#dist=(dist)","text":"[ View source ]","title":"#dist="},{"location":"constraints.html#CP::Constraint::PivotJoint","text":"Allows two objects to pivot about a single point.","title":"PivotJoint"},{"location":"constraints.html#class-methods_5","text":"","title":"Class methods"},{"location":"constraints.html#CP::Constraint::PivotJoint.new(a,b,anchor_a,anchor_b)","text":"a and b are the two bodies to connect, and anchor_a and anchor_b are the points in local coordinates where the pivot is located. [ View source ]","title":".new"},{"location":"constraints.html#methods_6","text":"","title":"Methods"},{"location":"constraints.html#CP::Constraint::PivotJoint#anchor_a()","text":"The location of the first anchor relative to the first body. [ View source ]","title":"#anchor_a"},{"location":"constraints.html#CP::Constraint::PivotJoint#anchor_a=(anchor_a)","text":"[ View source ]","title":"#anchor_a="},{"location":"constraints.html#CP::Constraint::PivotJoint#anchor_b()","text":"The location of the second anchor relative to the second body. [ View source ]","title":"#anchor_b"},{"location":"constraints.html#CP::Constraint::PivotJoint#anchor_b=(anchor_b)","text":"[ View source ]","title":"#anchor_b="},{"location":"constraints.html#CP::Constraint::RatchetJoint","text":"Works like a socket wrench.","title":"RatchetJoint"},{"location":"constraints.html#class-methods_6","text":"","title":"Class methods"},{"location":"constraints.html#CP::Constraint::RatchetJoint.new(a,b,phase,ratchet)","text":"ratchet is the distance between \"clicks\", phase is the initial offset to use when deciding where the ratchet angles are. [ View source ]","title":".new"},{"location":"constraints.html#methods_7","text":"","title":"Methods"},{"location":"constraints.html#CP::Constraint::RatchetJoint#angle()","text":"The angle of the current ratchet tooth. [ View source ]","title":"#angle"},{"location":"constraints.html#CP::Constraint::RatchetJoint#angle=(angle)","text":"[ View source ]","title":"#angle="},{"location":"constraints.html#CP::Constraint::RatchetJoint#phase()","text":"The phase offset of the ratchet. [ View source ]","title":"#phase"},{"location":"constraints.html#CP::Constraint::RatchetJoint#phase=(phase)","text":"[ View source ]","title":"#phase="},{"location":"constraints.html#CP::Constraint::RatchetJoint#ratchet()","text":"The angular distance of each ratchet. [ View source ]","title":"#ratchet"},{"location":"constraints.html#CP::Constraint::RatchetJoint#ratchet=(ratchet)","text":"[ View source ]","title":"#ratchet="},{"location":"constraints.html#CP::Constraint::RotaryLimitJoint","text":"Constrains the relative rotations of two bodies.","title":"RotaryLimitJoint"},{"location":"constraints.html#class-methods_7","text":"","title":"Class methods"},{"location":"constraints.html#CP::Constraint::RotaryLimitJoint.new(a,b,min,max)","text":"min and max are the angular limits in radians. It is implemented so that it's possible to for the range to be greater than a full revolution. [ View source ]","title":".new"},{"location":"constraints.html#methods_8","text":"","title":"Methods"},{"location":"constraints.html#CP::Constraint::RotaryLimitJoint#max()","text":"The maximum distance the joint will maintain between the two anchors. [ View source ]","title":"#max"},{"location":"constraints.html#CP::Constraint::RotaryLimitJoint#max=(max)","text":"[ View source ]","title":"#max="},{"location":"constraints.html#CP::Constraint::RotaryLimitJoint#min()","text":"The minimum distance the joint will maintain between the two anchors. [ View source ]","title":"#min"},{"location":"constraints.html#CP::Constraint::RotaryLimitJoint#min=(min)","text":"[ View source ]","title":"#min="},{"location":"constraints.html#CP::Constraint::SimpleMotor","text":"Keeps the relative angular velocity of a pair of bodies constant.","title":"SimpleMotor"},{"location":"constraints.html#class-methods_8","text":"","title":"Class methods"},{"location":"constraints.html#CP::Constraint::SimpleMotor.new(a,b,rate)","text":"[ View source ]","title":".new"},{"location":"constraints.html#methods_9","text":"","title":"Methods"},{"location":"constraints.html#CP::Constraint::SimpleMotor#rate()","text":"The desired relative angular velocity of the motor. You will usually want to set a force (torque) maximum for motors as otherwise they will be able to apply a nearly infinite torque to keep the bodies moving. [ View source ]","title":"#rate"},{"location":"constraints.html#CP::Constraint::SimpleMotor#rate=(rate)","text":"[ View source ]","title":"#rate="},{"location":"constraints.html#CP::Constraint::SlideJoint","text":"Like pin joints, but have a minimum and maximum distance. A chain could be modeled using this joint. It keeps the anchor points from getting too far apart, but will allow them to get closer together.","title":"SlideJoint"},{"location":"constraints.html#class-methods_9","text":"","title":"Class methods"},{"location":"constraints.html#CP::Constraint::SlideJoint.new(a,b,anchor_a,anchor_b,min,max)","text":"a and b are the two bodies to connect, anchor_a and anchor_b are the anchor points on those bodies, and min and max define the allowed distances of the anchor points. [ View source ]","title":".new"},{"location":"constraints.html#methods_10","text":"","title":"Methods"},{"location":"constraints.html#CP::Constraint::SlideJoint#anchor_a()","text":"The location of the first anchor relative to the first body. [ View source ]","title":"#anchor_a"},{"location":"constraints.html#CP::Constraint::SlideJoint#anchor_a=(anchor_a)","text":"[ View source ]","title":"#anchor_a="},{"location":"constraints.html#CP::Constraint::SlideJoint#anchor_b()","text":"The location of the second anchor relative to the second body. [ View source ]","title":"#anchor_b"},{"location":"constraints.html#CP::Constraint::SlideJoint#anchor_b=(anchor_b)","text":"[ View source ]","title":"#anchor_b="},{"location":"constraints.html#CP::Constraint::SlideJoint#max()","text":"The maximum distance the joint will maintain between the two anchors. [ View source ]","title":"#max"},{"location":"constraints.html#CP::Constraint::SlideJoint#max=(max)","text":"[ View source ]","title":"#max="},{"location":"constraints.html#CP::Constraint::SlideJoint#min()","text":"The minimum distance the joint will maintain between the two anchors. [ View source ]","title":"#min"},{"location":"constraints.html#CP::Constraint::SlideJoint#min=(min)","text":"[ View source ]","title":"#min="},{"location":"debug-draw.html","text":"abstract class CP::Space::DebugDraw inherits Reference # Direct known subclasses # SFMLDebugDraw Constants # COLLISION_POINT_COLOR # Color passed to drawing functions for collision points. CONSTRAINT_COLOR # Color passed to drawing functions for constraints. SHAPE_OUTLINE_COLOR # Outline color passed to the drawing function. Class methods # .color_for_hash ( hash : Int , intensity : Number ) : Color # [ View source ] .new ( flags = Flags :: All ) # [ View source ] Methods # #color_for_shape ( shape : Shape ) : Color # Returns a color for a given shape. This gives you an opportunity to color shapes based on how they are used in your engine. [ View source ] #draw ( space : Space ) # Debug draw the current state of the space. [ View source ] abstract #draw_circle ( pos : Vect , angle : Float64 , radius : Float64 , outline_color : Color , fill_color : Color ) # Draw a filled, stroked circle. [ View source ] abstract #draw_dot ( size : Float64 , pos : Vect , color : Color ) # Draw a dot. [ View source ] abstract #draw_fat_segment ( a : Vect , b : Vect , radius : Float64 , outline_color : Color , fill_color : Color ) # Draw a thick line segment. [ View source ] abstract #draw_polygon ( verts : Slice ( Vect ), radius : Float64 , outline_color : Color , fill_color : Color ) # Draw a convex polygon. [ View source ] abstract #draw_segment ( a : Vect , b : Vect , color : Color ) # Draw a line segment. [ View source ] #flags : Flags # [ View source ] #flags= ( flags : Flags ) # [ View source ] struct CP::Space::DebugDraw::Color inherits Struct # Color type to use with the space debug drawing API. Class methods # .gray ( l : Float , a : Float = 1.0_f32 ) : self # [ View source ] .new ( r : Float , g : Float , b : Float , a : Float = 1.0_f32 ) # [ View source ] Methods # #a : Float32 # [ View source ] #a= ( a : Float32 ) # [ View source ] #b : Float32 # [ View source ] #b= ( b : Float32 ) # [ View source ] #g : Float32 # [ View source ] #g= ( g : Float32 ) # [ View source ] #r : Float32 # [ View source ] #r= ( r : Float32 ) # [ View source ] enum CP::Space::DebugDraw::Flags # Flags that request which things to draw (collision shapes, constraints, contact points). Members # DRAW_SHAPES # DRAW_CONSTRAINTS # DRAW_COLLISION_POINTS # Methods # #draw_collision_points? # [ View source ] #draw_constraints? # [ View source ] #draw_shapes? # [ View source ] #none? # [ View source ] class SFMLDebugDraw inherits CP::Space::DebugDraw # Class methods # .new ( target : SF :: RenderTarget , states : SF :: RenderStates = SF :: RenderStates :: Default ) # [ View source ] Methods # #draw_circle ( pos : CP :: Vect , angle : Float64 , radius : Float64 , outline_color : Color , fill_color : Color ) # Draw a filled, stroked circle. [ View source ] #draw_dot ( size : Float64 , pos : CP :: Vect , color : Color ) # Draw a dot. [ View source ] #draw_fat_segment ( a : CP :: Vect , b : CP :: Vect , radius : Float64 , outline_color : Color , fill_color : Color ) # Draw a thick line segment. [ View source ] #draw_polygon ( verts : Slice ( CP :: Vect ), radius : Float64 , outline_color : Color , fill_color : Color ) # Draw a convex polygon. [ View source ] #draw_segment ( a : CP :: Vect , b : CP :: Vect , color : Color ) # Draw a line segment. [ View source ] #states : SF :: RenderStates # [ View source ] #states= ( states : SF :: RenderStates ) # [ View source ] #update # [ View source ] class SFMLDebugDraw::RoundedPolygon inherits SF::Shape # Class methods # .new # [ View source ] Methods # #assign ( points , radius : Number ) # [ View source ] #get_point ( index : Int ) : SF :: Vector2f # Get a point of the shape The returned point is in local coordinates, that is, the shape's transforms (position, rotation, scale) are not taken into account. The result is undefined if index is out of the valid range. index - Index of the point to get, in range 0 ... point_count Returns: index-th point of the shape See also: point_count [ View source ] #point_count : Int32 # Get the total number of points of the shape Returns: Number of points of the shape See also: point [ View source ]","title":"Debug draw"},{"location":"debug-draw.html#CP::Space::DebugDraw","text":"","title":"DebugDraw"},{"location":"debug-draw.html#direct-known-subclasses","text":"SFMLDebugDraw","title":"Direct known subclasses"},{"location":"debug-draw.html#constants","text":"","title":"Constants"},{"location":"debug-draw.html#CP::Space::DebugDraw::COLLISION_POINT_COLOR","text":"Color passed to drawing functions for collision points.","title":"COLLISION_POINT_COLOR"},{"location":"debug-draw.html#CP::Space::DebugDraw::CONSTRAINT_COLOR","text":"Color passed to drawing functions for constraints.","title":"CONSTRAINT_COLOR"},{"location":"debug-draw.html#CP::Space::DebugDraw::SHAPE_OUTLINE_COLOR","text":"Outline color passed to the drawing function.","title":"SHAPE_OUTLINE_COLOR"},{"location":"debug-draw.html#class-methods","text":"","title":"Class methods"},{"location":"debug-draw.html#CP::Space::DebugDraw.color_for_hash(hash,intensity)","text":"[ View source ]","title":".color_for_hash"},{"location":"debug-draw.html#CP::Space::DebugDraw.new(flags)","text":"[ View source ]","title":".new"},{"location":"debug-draw.html#methods","text":"","title":"Methods"},{"location":"debug-draw.html#CP::Space::DebugDraw#color_for_shape(shape)","text":"Returns a color for a given shape. This gives you an opportunity to color shapes based on how they are used in your engine. [ View source ]","title":"#color_for_shape"},{"location":"debug-draw.html#CP::Space::DebugDraw#draw(space)","text":"Debug draw the current state of the space. [ View source ]","title":"#draw"},{"location":"debug-draw.html#CP::Space::DebugDraw#draw_circle(pos,angle,radius,outline_color,fill_color)","text":"Draw a filled, stroked circle. [ View source ]","title":"#draw_circle"},{"location":"debug-draw.html#CP::Space::DebugDraw#draw_dot(size,pos,color)","text":"Draw a dot. [ View source ]","title":"#draw_dot"},{"location":"debug-draw.html#CP::Space::DebugDraw#draw_fat_segment(a,b,radius,outline_color,fill_color)","text":"Draw a thick line segment. [ View source ]","title":"#draw_fat_segment"},{"location":"debug-draw.html#CP::Space::DebugDraw#draw_polygon(verts,radius,outline_color,fill_color)","text":"Draw a convex polygon. [ View source ]","title":"#draw_polygon"},{"location":"debug-draw.html#CP::Space::DebugDraw#draw_segment(a,b,color)","text":"Draw a line segment. [ View source ]","title":"#draw_segment"},{"location":"debug-draw.html#CP::Space::DebugDraw#flags()","text":"[ View source ]","title":"#flags"},{"location":"debug-draw.html#CP::Space::DebugDraw#flags=(flags)","text":"[ View source ]","title":"#flags="},{"location":"debug-draw.html#CP::Space::DebugDraw::Color","text":"Color type to use with the space debug drawing API.","title":"Color"},{"location":"debug-draw.html#class-methods_1","text":"","title":"Class methods"},{"location":"debug-draw.html#CP::Space::DebugDraw::Color.gray(l,a)","text":"[ View source ]","title":".gray"},{"location":"debug-draw.html#CP::Space::DebugDraw::Color.new(r,g,b,a)","text":"[ View source ]","title":".new"},{"location":"debug-draw.html#methods_1","text":"","title":"Methods"},{"location":"debug-draw.html#CP::Space::DebugDraw::Color#a()","text":"[ View source ]","title":"#a"},{"location":"debug-draw.html#CP::Space::DebugDraw::Color#a=(a)","text":"[ View source ]","title":"#a="},{"location":"debug-draw.html#CP::Space::DebugDraw::Color#b()","text":"[ View source ]","title":"#b"},{"location":"debug-draw.html#CP::Space::DebugDraw::Color#b=(b)","text":"[ View source ]","title":"#b="},{"location":"debug-draw.html#CP::Space::DebugDraw::Color#g()","text":"[ View source ]","title":"#g"},{"location":"debug-draw.html#CP::Space::DebugDraw::Color#g=(g)","text":"[ View source ]","title":"#g="},{"location":"debug-draw.html#CP::Space::DebugDraw::Color#r()","text":"[ View source ]","title":"#r"},{"location":"debug-draw.html#CP::Space::DebugDraw::Color#r=(r)","text":"[ View source ]","title":"#r="},{"location":"debug-draw.html#CP::Space::DebugDraw::Flags","text":"Flags that request which things to draw (collision shapes, constraints, contact points).","title":"Flags"},{"location":"debug-draw.html#members","text":"","title":"Members"},{"location":"debug-draw.html#CP::Space::DebugDraw::Flags::DRAW_SHAPES","text":"","title":"DRAW_SHAPES"},{"location":"debug-draw.html#CP::Space::DebugDraw::Flags::DRAW_CONSTRAINTS","text":"","title":"DRAW_CONSTRAINTS"},{"location":"debug-draw.html#CP::Space::DebugDraw::Flags::DRAW_COLLISION_POINTS","text":"","title":"DRAW_COLLISION_POINTS"},{"location":"debug-draw.html#methods_2","text":"","title":"Methods"},{"location":"debug-draw.html#CP::Space::DebugDraw::Flags#draw_collision_points?()","text":"[ View source ]","title":"#draw_collision_points?"},{"location":"debug-draw.html#CP::Space::DebugDraw::Flags#draw_constraints?()","text":"[ View source ]","title":"#draw_constraints?"},{"location":"debug-draw.html#CP::Space::DebugDraw::Flags#draw_shapes?()","text":"[ View source ]","title":"#draw_shapes?"},{"location":"debug-draw.html#CP::Space::DebugDraw::Flags#none?()","text":"[ View source ]","title":"#none?"},{"location":"debug-draw.html#SFMLDebugDraw","text":"","title":"SFMLDebugDraw"},{"location":"debug-draw.html#class-methods_2","text":"","title":"Class methods"},{"location":"debug-draw.html#SFMLDebugDraw.new(target,states)","text":"[ View source ]","title":".new"},{"location":"debug-draw.html#methods_3","text":"","title":"Methods"},{"location":"debug-draw.html#SFMLDebugDraw#draw_circle(pos,angle,radius,outline_color,fill_color)","text":"Draw a filled, stroked circle. [ View source ]","title":"#draw_circle"},{"location":"debug-draw.html#SFMLDebugDraw#draw_dot(size,pos,color)","text":"Draw a dot. [ View source ]","title":"#draw_dot"},{"location":"debug-draw.html#SFMLDebugDraw#draw_fat_segment(a,b,radius,outline_color,fill_color)","text":"Draw a thick line segment. [ View source ]","title":"#draw_fat_segment"},{"location":"debug-draw.html#SFMLDebugDraw#draw_polygon(verts,radius,outline_color,fill_color)","text":"Draw a convex polygon. [ View source ]","title":"#draw_polygon"},{"location":"debug-draw.html#SFMLDebugDraw#draw_segment(a,b,color)","text":"Draw a line segment. [ View source ]","title":"#draw_segment"},{"location":"debug-draw.html#SFMLDebugDraw#states()","text":"[ View source ]","title":"#states"},{"location":"debug-draw.html#SFMLDebugDraw#states=(states)","text":"[ View source ]","title":"#states="},{"location":"debug-draw.html#SFMLDebugDraw#update()","text":"[ View source ]","title":"#update"},{"location":"debug-draw.html#SFMLDebugDraw::RoundedPolygon","text":"","title":"RoundedPolygon"},{"location":"debug-draw.html#class-methods_3","text":"","title":"Class methods"},{"location":"debug-draw.html#SFMLDebugDraw::RoundedPolygon.new()","text":"[ View source ]","title":".new"},{"location":"debug-draw.html#methods_4","text":"","title":"Methods"},{"location":"debug-draw.html#SFMLDebugDraw::RoundedPolygon#assign(points,radius)","text":"[ View source ]","title":"#assign"},{"location":"debug-draw.html#SFMLDebugDraw::RoundedPolygon#get_point(index)","text":"Get a point of the shape The returned point is in local coordinates, that is, the shape's transforms (position, rotation, scale) are not taken into account. The result is undefined if index is out of the valid range. index - Index of the point to get, in range 0 ... point_count Returns: index-th point of the shape See also: point_count [ View source ]","title":"#get_point"},{"location":"debug-draw.html#SFMLDebugDraw::RoundedPolygon#point_count()","text":"Get the total number of points of the shape Returns: Number of points of the shape See also: point [ View source ]","title":"#point_count"},{"location":"queries.html","text":"CP::Space # #point_query ( point : Vect , max_distance : Number = 0 , filter : ShapeFilter = ShapeFilter :: ALL ) : Array ( PointQueryInfo ) # Query the space at a point for shapes within the given distance range. The filter is applied to the query and follows the same rules as the collision detection. Sensor shapes are included. If a max_distance of 0 is used, the point must lie inside a shape. Negative max_distance is also allowed meaning that the point must be a under a certain depth within a shape to be considered a match. [ View source ] #segment_query ( start : Vect , end end_ : Vect , radius : Number = 0 , filter : ShapeFilter = ShapeFilter :: ALL ) : Array ( SegmentQueryInfo ) # Perform a directed line segment query (like a raycast) against the space and yield each shape intersected. The filter is applied to the query and follows the same rules as the collision detection. Sensor shapes are included. [ View source ] #shape_query ( shape : Shape ) : Array ( Shape ) # Query a space for any shapes overlapping the given shape and yield each shape found. [ View source ] CP::Shape # #point_query ( p : Vect ) : PointQueryInfo # Perform a nearest point query. It finds the closest point on the surface of shape to a specific point. [ View source ] #segment_query ( a : Vect , b : Vect , radius : Number = 0 ) : SegmentQueryInfo? # Perform a segment query against a shape: check if the line segment from start to end intersects the shape. [ View source ] struct CP::PointQueryInfo inherits Struct # Holds the result of a point query made on a Shape or Space . Class methods # .new ( shape : Shape , point : Vect , distance : Float64 , gradient : Vect ) # [ View source ] Methods # #distance : Float64 # The distance to the point (negative if the point is inside the shape). [ View source ] #distance= ( distance : Float64 ) # [ View source ] #gradient : Vect # The gradient of the signed distance function. The value should be similar to point/distance , but accurate even for very small values of distance . [ View source ] #gradient= ( gradient : Vect ) # [ View source ] #point : Vect # The closest point on the shape's surface (in world space coordinates). [ View source ] #point= ( point : Vect ) # [ View source ] #shape : Shape # The nearest shape [ View source ] #shape= ( shape : Shape ) # [ View source ] struct CP::SegmentQueryInfo inherits Struct # Segment queries return more information than just a simple yes or no, they also return where a shape was hit and its surface normal at the hit point. This object holds that information. Segment queries are like ray casting, but because not all spatial indexes allow processing infinitely long ray queries it is limited to segments. In practice this is still very fast and you don't need to worry too much about the performance as long as you aren't using extremely long segments for your queries. Class methods # .new ( shape : Shape , point : Vect , normal : Vect , alpha : Float64 ) # [ View source ] Methods # #alpha : Float64 # The normalized distance along the query segment in the range [0, 1]. [ View source ] #alpha= ( alpha : Float64 ) # [ View source ] #normal : Vect # The normal of the surface hit. [ View source ] #normal= ( normal : Vect ) # [ View source ] #point : Vect # The point of impact. [ View source ] #point= ( point : Vect ) # [ View source ] #shape : Shape # The shape that was hit. [ View source ] #shape= ( shape : Shape ) # [ View source ]","title":"Queries"},{"location":"queries.html#cpspace","text":"","title":"CP::Space"},{"location":"queries.html#CP::Space#point_query(point,max_distance,filter)","text":"Query the space at a point for shapes within the given distance range. The filter is applied to the query and follows the same rules as the collision detection. Sensor shapes are included. If a max_distance of 0 is used, the point must lie inside a shape. Negative max_distance is also allowed meaning that the point must be a under a certain depth within a shape to be considered a match. [ View source ]","title":"#point_query"},{"location":"queries.html#CP::Space#segment_query(start,end,radius,filter)","text":"Perform a directed line segment query (like a raycast) against the space and yield each shape intersected. The filter is applied to the query and follows the same rules as the collision detection. Sensor shapes are included. [ View source ]","title":"#segment_query"},{"location":"queries.html#CP::Space#shape_query(shape)","text":"Query a space for any shapes overlapping the given shape and yield each shape found. [ View source ]","title":"#shape_query"},{"location":"queries.html#cpshape","text":"","title":"CP::Shape"},{"location":"queries.html#CP::Shape#point_query(p)","text":"Perform a nearest point query. It finds the closest point on the surface of shape to a specific point. [ View source ]","title":"#point_query"},{"location":"queries.html#CP::Shape#segment_query(a,b,radius)","text":"Perform a segment query against a shape: check if the line segment from start to end intersects the shape. [ View source ]","title":"#segment_query"},{"location":"queries.html#CP::PointQueryInfo","text":"Holds the result of a point query made on a Shape or Space .","title":"PointQueryInfo"},{"location":"queries.html#class-methods","text":"","title":"Class methods"},{"location":"queries.html#CP::PointQueryInfo.new(shape,point,distance,gradient)","text":"[ View source ]","title":".new"},{"location":"queries.html#methods","text":"","title":"Methods"},{"location":"queries.html#CP::PointQueryInfo#distance()","text":"The distance to the point (negative if the point is inside the shape). [ View source ]","title":"#distance"},{"location":"queries.html#CP::PointQueryInfo#distance=(distance)","text":"[ View source ]","title":"#distance="},{"location":"queries.html#CP::PointQueryInfo#gradient()","text":"The gradient of the signed distance function. The value should be similar to point/distance , but accurate even for very small values of distance . [ View source ]","title":"#gradient"},{"location":"queries.html#CP::PointQueryInfo#gradient=(gradient)","text":"[ View source ]","title":"#gradient="},{"location":"queries.html#CP::PointQueryInfo#point()","text":"The closest point on the shape's surface (in world space coordinates). [ View source ]","title":"#point"},{"location":"queries.html#CP::PointQueryInfo#point=(point)","text":"[ View source ]","title":"#point="},{"location":"queries.html#CP::PointQueryInfo#shape()","text":"The nearest shape [ View source ]","title":"#shape"},{"location":"queries.html#CP::PointQueryInfo#shape=(shape)","text":"[ View source ]","title":"#shape="},{"location":"queries.html#CP::SegmentQueryInfo","text":"Segment queries return more information than just a simple yes or no, they also return where a shape was hit and its surface normal at the hit point. This object holds that information. Segment queries are like ray casting, but because not all spatial indexes allow processing infinitely long ray queries it is limited to segments. In practice this is still very fast and you don't need to worry too much about the performance as long as you aren't using extremely long segments for your queries.","title":"SegmentQueryInfo"},{"location":"queries.html#class-methods_1","text":"","title":"Class methods"},{"location":"queries.html#CP::SegmentQueryInfo.new(shape,point,normal,alpha)","text":"[ View source ]","title":".new"},{"location":"queries.html#methods_1","text":"","title":"Methods"},{"location":"queries.html#CP::SegmentQueryInfo#alpha()","text":"The normalized distance along the query segment in the range [0, 1]. [ View source ]","title":"#alpha"},{"location":"queries.html#CP::SegmentQueryInfo#alpha=(alpha)","text":"[ View source ]","title":"#alpha="},{"location":"queries.html#CP::SegmentQueryInfo#normal()","text":"The normal of the surface hit. [ View source ]","title":"#normal"},{"location":"queries.html#CP::SegmentQueryInfo#normal=(normal)","text":"[ View source ]","title":"#normal="},{"location":"queries.html#CP::SegmentQueryInfo#point()","text":"The point of impact. [ View source ]","title":"#point"},{"location":"queries.html#CP::SegmentQueryInfo#point=(point)","text":"[ View source ]","title":"#point="},{"location":"queries.html#CP::SegmentQueryInfo#shape()","text":"The shape that was hit. [ View source ]","title":"#shape"},{"location":"queries.html#CP::SegmentQueryInfo#shape=(shape)","text":"[ View source ]","title":"#shape="},{"location":"shapes.html","text":"abstract class CP::Shape inherits Reference # Defines the shape of a rigid body. Direct known subclasses # CP::Shape::Circle CP::Shape::Poly CP::Shape::Segment Methods # #area : Float64 # Get the calculated area of this shape. [ View source ] #bb : BB # Get the bounding box that contains the shape given its current position and angle. Only guaranteed to be valid after cache_bb or Space#step is called. Moving a body that a shape is connected to does not update its bounding box. For shapes used for queries that aren't attached to bodies, you can also use update . [ View source ] #body : Body? # The Body this shape is added to. [ View source ] #body= ( body : Body? ) # Set the Body this shape is added to. Can only be used if the shape is not currently added to a space. [ View source ] #cache_bb : BB # Update, cache and return the bounding box of a shape based on the body it's attached to. [ View source ] #center_of_gravity : Vect # Get the centroid of this shape. [ View source ] #collide ( b : Shape ) : ContactPointSet # Return contact information about two shapes. [ View source ] #collision_type : CollisionType # User defined collision type for the shape. See Space#add_collision_handler for more information. [ View source ] #collision_type= ( collision_type : Int ) # [ View source ] #density : Float64 # Get the density of the shape if you are having Chipmunk calculate mass properties for you. [ View source ] #density= ( density : Number ) # Set the density of this shape to have Chipmunk calculate mass properties for you. [ View source ] #elasticity : Float64 # The elasticity of this shape. A value of 0.0 gives no bounce, while a value of 1.0 will give a 'perfect' bounce. However due to inaccuracies in the simulation using 1.0 or greater is not recommended. [ View source ] #elasticity= ( elasticity : Number ) # [ View source ] #filter : ShapeFilter # The collision filtering parameters of this shape. [ View source ] #filter= ( filter : ShapeFilter ) # [ View source ] #friction : Float64 # The friction of this shape. Chipmunk uses the Coulomb friction model, a value of 0.0 is frictionless. A value over 1.0 is also perfectly fine. [ View source ] #friction= ( friction : Number ) # [ View source ] #mass : Float64 # Get the mass of the shape if you are having Chipmunk calculate mass properties for you. [ View source ] #mass= ( mass : Number ) # Set the mass of this shape to have Chipmunk calculate mass properties for you. [ View source ] #moment : Float64 # Get the calculated moment of inertia for this shape. [ View source ] #point_query ( p : Vect ) : PointQueryInfo # Perform a nearest point query. It finds the closest point on the surface of shape to a specific point. [ View source ] #segment_query ( a : Vect , b : Vect , radius : Number = 0 ) : SegmentQueryInfo? # Perform a segment query against a shape: check if the line segment from start to end intersects the shape. [ View source ] #sensor= ( sensor : Bool ) # [ View source ] #sensor? : Bool # Is the shape set to be a sensor or not? Sensors only call collision callbacks, and never generate real collisions. [ View source ] #space : Space? # The Space this shape is added to. [ View source ] #surface_velocity : Vect # The surface velocity of this shape. Useful for creating conveyor belts or players that move around. This value is only used when calculating friction, not resolving the collision. [ View source ] #surface_velocity= ( surface_velocity : Vect ) # [ View source ] #update ( transform : Transform ) : BB # Update, cache and return the bounding box of a shape with an explicit transformation. Useful if you have a shape without a body and want to use it for querying. [ View source ] class CP::Shape::Box inherits CP::Shape::Poly # A special case of a polygon - a rectangle. The boxes will always be centered at the center of gravity of the body you are attaching them to. If you want to create an off-center box, you will need to use Poly . Class methods # .moment ( m : Number , width : Number , height : Number ) : Float64 # Calculate the moment of inertia for a solid box. [ View source ] .moment ( m : Number , box : BB ) : Float64 # Calculate the moment of inertia for a solid box. [ View source ] .new ( body : Body? , width : Number , height : Number , radius : Number = 0 ) # Initialize a box shaped polygon shape with rounded corners. [ View source ] .new ( body : Body? , box : BB , radius : Number = 0 ) # Initialize an offset box shaped polygon shape with rounded corners. [ View source ] class CP::Shape::Circle inherits CP::Shape # A circle shape defined by a radius This is the fastest and simplest collision shape Class methods # .area ( r1 : Number , r2 : Number ) : Float64 # Calculate area of a hollow circle. r1 and r2 are the inner and outer diameters. A solid circle has an inner diameter of 0. [ View source ] .moment ( m : Number , r1 : Number , r2 : Number , offset : Vect = CP :: Vect . new ( 0 , 0 )) : Float64 # Calculate the moment of inertia for a circle. r1 and r2 are the inner and outer diameters. A solid circle has an inner diameter of 0. [ View source ] .new ( body : Body? , radius : Number , offset : Vect = CP :: Vect . new ( 0 , 0 )) # The parameters are: the body to attach the circle to; the offset from the body's center of gravity in body local coordinates. [ View source ] Methods # #offset : Vect # Get the offset of a circle shape. [ View source ] #offset= ( offset : Vect ) # Unsafe. Set the offset of a circle shape. This change is only picked up as a change to the position of the shape's surface, but not its velocity. Changing it will not result in realistic physical behavior. Only use if you know what you are doing! [ View source ] #radius : Float64 # Get the radius of a circle shape. [ View source ] #radius= ( radius : Number ) # Unsafe. Set the radius of a circle shape. This change is only picked up as a change to the position of the shape's surface, but not its velocity. Changing it will not result in realistic physical behavior. Only use if you know what you are doing! [ View source ] class CP::Shape::Poly inherits CP::Shape # A convex polygon shape Slowest, but most flexible collision shape. Included modules # Enumerable Indexable Direct known subclasses # CP::Shape::Box Class methods # .area ( verts : Array ( Vect ) | Slice ( Vect ), radius : Number = 0 ) : Float64 # Calculate the signed area of a polygon. A clockwise winding gives positive area. This is probably backwards from what you expect, but matches Chipmunk's winding for poly shapes. [ View source ] .centroid ( verts : Array ( Vect ) | Slice ( Vect )) : Vect # Calculate the natural centroid of a polygon. [ View source ] .convex_hull ( verts : Array ( Vect ) | Slice ( Vect ), tol : Number = 0 ) : Tuple ( Slice ( Vect ), Int32 ) # Calculate the convex hull of a given set of points. tol is the allowed amount to shrink the hull when simplifying it. A tolerance of 0.0 creates an exact hull. Returns the convex hull and the index where the first vertex in the hull came from (i.e. verts[first] == result[0] ) [ View source ] .moment ( m : Number , verts : Array ( Vect ) | Slice ( Vect ), offset : Vect = CP :: Vect . new ( 0 , 0 ), radius : Number = 0 ) : Float64 # Calculate the moment of inertia for a solid polygon shape. Assumes its center of gravity is at its centroid. The offset is added to each vertex. [ View source ] .new ( body : Body? , verts : Array ( Vect ) | Slice ( Vect ), transform : Transform = Transform :: IDENTITY , radius : Number = 0 ) # Initialize a polygon shape with rounded corners. A convex hull will be created from the vertices. The parameters are: the body to attach the poly to; the verts (vertices) of the polygon; the transform to apply to every vertex; the radius of the corners. Adding a small radius will bevel the corners and can significantly reduce problems where the poly gets stuck on seams in your geometry. [ View source ] .new ( body : Body? , verts : Array ( Vect ) | Slice ( Vect ), radius : Number ) # Initialize a polygon shape with rounded corners. The vertices must be convex with a counter-clockwise winding. [ View source ] Methods # #radius : Float64 # Get the radius of a polygon shape. [ View source ] #radius= ( radius : Number ) # Unsafe. Set the radius of a poly shape. This change is only picked up as a change to the position of the shape's surface, but not its velocity. Changing it will not result in realistic physical behavior. Only use if you know what you are doing! [ View source ] #set_verts ( verts : Array ( Vect ) | Slice ( Vect ), transform : Transform = Transform :: IDENTITY ) # Unsafe. Set the vertices of a poly shape. This change is only picked up as a change to the position of the shape's surface, but not its velocity. Changing it will not result in realistic physical behavior. Only use if you know what you are doing! [ View source ] #size : Int32 # Get the number of verts in a polygon shape. [ View source ] #unsafe_fetch ( index : Int ) : Vect # Get the i -th vertex of a polygon shape. [ View source ] class CP::Shape::Segment inherits CP::Shape # A line segment shape between two points. Meant mainly as a static shape. Can be beveled in order to give them a thickness. Class methods # .area ( a : Vect , b : Vect , radius : Number ) : Float64 # Calculate the area of a fattened (capsule shaped) line segment. [ View source ] .moment ( m : Number , a : Vect , b : Vect , radius : Number = 0 ) : Float64 # Calculate the moment of inertia for a line segment. Beveling radius is not supported. [ View source ] .new ( body : Body? , a : Vect , b : Vect , radius : Number = 0 ) # The parameters are: the body to attach the segment to; the endpoints ( a , b ) to attach the segment to; the radius of the half-circles at the ends of the segment (thickness is twice the radius). [ View source ] Methods # #a : Vect # Get the first endpoint of a segment shape. [ View source ] #b : Vect # Get the second endpoint of a segment shape. [ View source ] #normal : Vect # Get the normal of a segment shape. [ View source ] #radius : Float64 # Get the radius of a segment shape. [ View source ] #radius= ( radius : Number ) # Unsafe. Set the radius of a segment shape. This change is only picked up as a change to the position of the shape's surface, but not its velocity. Changing it will not result in realistic physical behavior. Only use if you know what you are doing! [ View source ] #set_endpoints ( a : Vect , b : Vect ) # Unsafe. Set the endpoints of a segment shape. This change is only picked up as a change to the position of the shape's surface, but not its velocity. Changing it will not result in realistic physical behavior. Only use if you know what you are doing! [ View source ] #set_neighbors ( prev : Vect , next next_ : Vect ) # Let Chipmunk know about the geometry of adjacent segments to avoid colliding with endcaps. When you have a number of segment shapes that are all joined together, things can still collide with the \"cracks\" between the segments. By setting the neighbor segment endpoints you can tell Chipmunk to avoid colliding with the inner parts of the crack. [ View source ] struct CP::ShapeFilter inherits Struct # Fast collision filtering type that is used to determine if two objects collide before calling collision or query callbacks. Chipmunk has two primary means of ignoring collisions: groups and category masks. Groups are used to ignore collisions between parts on a complex object. A ragdoll is a good example. When jointing an arm onto the torso, you'll want them to allow them to overlap. Groups allow you to do exactly that. Shapes that have the same group don't generate collisions. So by placing all of the shapes in a ragdoll in the same group, you'll prevent it from colliding against other parts of itself. Category masks allow you to mark which categories an object belongs to and which categories it collidies with. By default, objects exist in every category and collide with every category. The type of categories and mask in ShapeFilter is UInt32 . There is one last way of filtering collisions using collision handlers. See the section on callbacks for more information. Collision handlers can be more flexible, but can be slower. Fast collision filtering rejects collisions before running the expensive collision detection code, so using groups or category masks is preferred. Constants # ALL # Collision filter value for a shape that will collide with anything except NONE . ALL_CATEGORIES # Value for signifying that a shape is in every category. NO_GROUP # Value signifying that a shape is in no group. NONE # Collision filter value for a shape that does not collide with anything. Class methods # .new ( group : Int = NO_GROUP , categories : Int = ALL_CATEGORIES , mask : Int = ALL_CATEGORIES ) # [ View source ] Methods # #categories : Bitmask # A bitmask of user definable categories that this object belongs to. The category/mask combinations of both objects in a collision must agree for a collision to occur. [ View source ] #categories= ( categories : Bitmask ) # [ View source ] #group : Group # Two objects with the same non-zero group value do not collide. This is generally used to group objects in a composite object together to disable self collisions. [ View source ] #group= ( group : Group ) # [ View source ] #mask : Bitmask # A bitmask of user definable category types that this object object collides with. The category/mask combinations of both objects in a collision must agree for a collision to occur. [ View source ] #mask= ( mask : Bitmask ) # [ View source ] alias CP::ShapeFilter::Bitmask # Alias definition # UInt32 alias CP::ShapeFilter::Group # Alias definition # UInt64","title":"Shapes"},{"location":"shapes.html#CP::Shape","text":"Defines the shape of a rigid body.","title":"Shape"},{"location":"shapes.html#direct-known-subclasses","text":"CP::Shape::Circle CP::Shape::Poly CP::Shape::Segment","title":"Direct known subclasses"},{"location":"shapes.html#methods","text":"","title":"Methods"},{"location":"shapes.html#CP::Shape#area()","text":"Get the calculated area of this shape. [ View source ]","title":"#area"},{"location":"shapes.html#CP::Shape#bb()","text":"Get the bounding box that contains the shape given its current position and angle. Only guaranteed to be valid after cache_bb or Space#step is called. Moving a body that a shape is connected to does not update its bounding box. For shapes used for queries that aren't attached to bodies, you can also use update . [ View source ]","title":"#bb"},{"location":"shapes.html#CP::Shape#body()","text":"The Body this shape is added to. [ View source ]","title":"#body"},{"location":"shapes.html#CP::Shape#body=(body)","text":"Set the Body this shape is added to. Can only be used if the shape is not currently added to a space. [ View source ]","title":"#body="},{"location":"shapes.html#CP::Shape#cache_bb()","text":"Update, cache and return the bounding box of a shape based on the body it's attached to. [ View source ]","title":"#cache_bb"},{"location":"shapes.html#CP::Shape#center_of_gravity()","text":"Get the centroid of this shape. [ View source ]","title":"#center_of_gravity"},{"location":"shapes.html#CP::Shape#collide(b)","text":"Return contact information about two shapes. [ View source ]","title":"#collide"},{"location":"shapes.html#CP::Shape#collision_type()","text":"User defined collision type for the shape. See Space#add_collision_handler for more information. [ View source ]","title":"#collision_type"},{"location":"shapes.html#CP::Shape#collision_type=(collision_type)","text":"[ View source ]","title":"#collision_type="},{"location":"shapes.html#CP::Shape#density()","text":"Get the density of the shape if you are having Chipmunk calculate mass properties for you. [ View source ]","title":"#density"},{"location":"shapes.html#CP::Shape#density=(density)","text":"Set the density of this shape to have Chipmunk calculate mass properties for you. [ View source ]","title":"#density="},{"location":"shapes.html#CP::Shape#elasticity()","text":"The elasticity of this shape. A value of 0.0 gives no bounce, while a value of 1.0 will give a 'perfect' bounce. However due to inaccuracies in the simulation using 1.0 or greater is not recommended. [ View source ]","title":"#elasticity"},{"location":"shapes.html#CP::Shape#elasticity=(elasticity)","text":"[ View source ]","title":"#elasticity="},{"location":"shapes.html#CP::Shape#filter()","text":"The collision filtering parameters of this shape. [ View source ]","title":"#filter"},{"location":"shapes.html#CP::Shape#filter=(filter)","text":"[ View source ]","title":"#filter="},{"location":"shapes.html#CP::Shape#friction()","text":"The friction of this shape. Chipmunk uses the Coulomb friction model, a value of 0.0 is frictionless. A value over 1.0 is also perfectly fine. [ View source ]","title":"#friction"},{"location":"shapes.html#CP::Shape#friction=(friction)","text":"[ View source ]","title":"#friction="},{"location":"shapes.html#CP::Shape#mass()","text":"Get the mass of the shape if you are having Chipmunk calculate mass properties for you. [ View source ]","title":"#mass"},{"location":"shapes.html#CP::Shape#mass=(mass)","text":"Set the mass of this shape to have Chipmunk calculate mass properties for you. [ View source ]","title":"#mass="},{"location":"shapes.html#CP::Shape#moment()","text":"Get the calculated moment of inertia for this shape. [ View source ]","title":"#moment"},{"location":"shapes.html#CP::Shape#point_query(p)","text":"Perform a nearest point query. It finds the closest point on the surface of shape to a specific point. [ View source ]","title":"#point_query"},{"location":"shapes.html#CP::Shape#segment_query(a,b,radius)","text":"Perform a segment query against a shape: check if the line segment from start to end intersects the shape. [ View source ]","title":"#segment_query"},{"location":"shapes.html#CP::Shape#sensor=(sensor)","text":"[ View source ]","title":"#sensor="},{"location":"shapes.html#CP::Shape#sensor?()","text":"Is the shape set to be a sensor or not? Sensors only call collision callbacks, and never generate real collisions. [ View source ]","title":"#sensor?"},{"location":"shapes.html#CP::Shape#space()","text":"The Space this shape is added to. [ View source ]","title":"#space"},{"location":"shapes.html#CP::Shape#surface_velocity()","text":"The surface velocity of this shape. Useful for creating conveyor belts or players that move around. This value is only used when calculating friction, not resolving the collision. [ View source ]","title":"#surface_velocity"},{"location":"shapes.html#CP::Shape#surface_velocity=(surface_velocity)","text":"[ View source ]","title":"#surface_velocity="},{"location":"shapes.html#CP::Shape#update(transform)","text":"Update, cache and return the bounding box of a shape with an explicit transformation. Useful if you have a shape without a body and want to use it for querying. [ View source ]","title":"#update"},{"location":"shapes.html#CP::Shape::Box","text":"A special case of a polygon - a rectangle. The boxes will always be centered at the center of gravity of the body you are attaching them to. If you want to create an off-center box, you will need to use Poly .","title":"Box"},{"location":"shapes.html#class-methods","text":"","title":"Class methods"},{"location":"shapes.html#CP::Shape::Box.moment(m,width,height)","text":"Calculate the moment of inertia for a solid box. [ View source ]","title":".moment"},{"location":"shapes.html#CP::Shape::Box.new(body,width,height,radius)","text":"Initialize a box shaped polygon shape with rounded corners. [ View source ]","title":".new"},{"location":"shapes.html#CP::Shape::Circle","text":"A circle shape defined by a radius This is the fastest and simplest collision shape","title":"Circle"},{"location":"shapes.html#class-methods_1","text":"","title":"Class methods"},{"location":"shapes.html#CP::Shape::Circle.area(r1,r2)","text":"Calculate area of a hollow circle. r1 and r2 are the inner and outer diameters. A solid circle has an inner diameter of 0. [ View source ]","title":".area"},{"location":"shapes.html#CP::Shape::Circle.moment(m,r1,r2,offset)","text":"Calculate the moment of inertia for a circle. r1 and r2 are the inner and outer diameters. A solid circle has an inner diameter of 0. [ View source ]","title":".moment"},{"location":"shapes.html#CP::Shape::Circle.new(body,radius,offset)","text":"The parameters are: the body to attach the circle to; the offset from the body's center of gravity in body local coordinates. [ View source ]","title":".new"},{"location":"shapes.html#methods_1","text":"","title":"Methods"},{"location":"shapes.html#CP::Shape::Circle#offset()","text":"Get the offset of a circle shape. [ View source ]","title":"#offset"},{"location":"shapes.html#CP::Shape::Circle#offset=(offset)","text":"Unsafe. Set the offset of a circle shape. This change is only picked up as a change to the position of the shape's surface, but not its velocity. Changing it will not result in realistic physical behavior. Only use if you know what you are doing! [ View source ]","title":"#offset="},{"location":"shapes.html#CP::Shape::Circle#radius()","text":"Get the radius of a circle shape. [ View source ]","title":"#radius"},{"location":"shapes.html#CP::Shape::Circle#radius=(radius)","text":"Unsafe. Set the radius of a circle shape. This change is only picked up as a change to the position of the shape's surface, but not its velocity. Changing it will not result in realistic physical behavior. Only use if you know what you are doing! [ View source ]","title":"#radius="},{"location":"shapes.html#CP::Shape::Poly","text":"A convex polygon shape Slowest, but most flexible collision shape.","title":"Poly"},{"location":"shapes.html#included-modules","text":"Enumerable Indexable","title":"Included modules"},{"location":"shapes.html#direct-known-subclasses_1","text":"CP::Shape::Box","title":"Direct known subclasses"},{"location":"shapes.html#class-methods_2","text":"","title":"Class methods"},{"location":"shapes.html#CP::Shape::Poly.area(verts,radius)","text":"Calculate the signed area of a polygon. A clockwise winding gives positive area. This is probably backwards from what you expect, but matches Chipmunk's winding for poly shapes. [ View source ]","title":".area"},{"location":"shapes.html#CP::Shape::Poly.centroid(verts)","text":"Calculate the natural centroid of a polygon. [ View source ]","title":".centroid"},{"location":"shapes.html#CP::Shape::Poly.convex_hull(verts,tol)","text":"Calculate the convex hull of a given set of points. tol is the allowed amount to shrink the hull when simplifying it. A tolerance of 0.0 creates an exact hull. Returns the convex hull and the index where the first vertex in the hull came from (i.e. verts[first] == result[0] ) [ View source ]","title":".convex_hull"},{"location":"shapes.html#CP::Shape::Poly.moment(m,verts,offset,radius)","text":"Calculate the moment of inertia for a solid polygon shape. Assumes its center of gravity is at its centroid. The offset is added to each vertex. [ View source ]","title":".moment"},{"location":"shapes.html#CP::Shape::Poly.new(body,verts,transform,radius)","text":"Initialize a polygon shape with rounded corners. A convex hull will be created from the vertices. The parameters are: the body to attach the poly to; the verts (vertices) of the polygon; the transform to apply to every vertex; the radius of the corners. Adding a small radius will bevel the corners and can significantly reduce problems where the poly gets stuck on seams in your geometry. [ View source ]","title":".new"},{"location":"shapes.html#methods_2","text":"","title":"Methods"},{"location":"shapes.html#CP::Shape::Poly#radius()","text":"Get the radius of a polygon shape. [ View source ]","title":"#radius"},{"location":"shapes.html#CP::Shape::Poly#radius=(radius)","text":"Unsafe. Set the radius of a poly shape. This change is only picked up as a change to the position of the shape's surface, but not its velocity. Changing it will not result in realistic physical behavior. Only use if you know what you are doing! [ View source ]","title":"#radius="},{"location":"shapes.html#CP::Shape::Poly#set_verts(verts,transform)","text":"Unsafe. Set the vertices of a poly shape. This change is only picked up as a change to the position of the shape's surface, but not its velocity. Changing it will not result in realistic physical behavior. Only use if you know what you are doing! [ View source ]","title":"#set_verts"},{"location":"shapes.html#CP::Shape::Poly#size()","text":"Get the number of verts in a polygon shape. [ View source ]","title":"#size"},{"location":"shapes.html#CP::Shape::Poly#unsafe_fetch(index)","text":"Get the i -th vertex of a polygon shape. [ View source ]","title":"#unsafe_fetch"},{"location":"shapes.html#CP::Shape::Segment","text":"A line segment shape between two points. Meant mainly as a static shape. Can be beveled in order to give them a thickness.","title":"Segment"},{"location":"shapes.html#class-methods_3","text":"","title":"Class methods"},{"location":"shapes.html#CP::Shape::Segment.area(a,b,radius)","text":"Calculate the area of a fattened (capsule shaped) line segment. [ View source ]","title":".area"},{"location":"shapes.html#CP::Shape::Segment.moment(m,a,b,radius)","text":"Calculate the moment of inertia for a line segment. Beveling radius is not supported. [ View source ]","title":".moment"},{"location":"shapes.html#CP::Shape::Segment.new(body,a,b,radius)","text":"The parameters are: the body to attach the segment to; the endpoints ( a , b ) to attach the segment to; the radius of the half-circles at the ends of the segment (thickness is twice the radius). [ View source ]","title":".new"},{"location":"shapes.html#methods_3","text":"","title":"Methods"},{"location":"shapes.html#CP::Shape::Segment#a()","text":"Get the first endpoint of a segment shape. [ View source ]","title":"#a"},{"location":"shapes.html#CP::Shape::Segment#b()","text":"Get the second endpoint of a segment shape. [ View source ]","title":"#b"},{"location":"shapes.html#CP::Shape::Segment#normal()","text":"Get the normal of a segment shape. [ View source ]","title":"#normal"},{"location":"shapes.html#CP::Shape::Segment#radius()","text":"Get the radius of a segment shape. [ View source ]","title":"#radius"},{"location":"shapes.html#CP::Shape::Segment#radius=(radius)","text":"Unsafe. Set the radius of a segment shape. This change is only picked up as a change to the position of the shape's surface, but not its velocity. Changing it will not result in realistic physical behavior. Only use if you know what you are doing! [ View source ]","title":"#radius="},{"location":"shapes.html#CP::Shape::Segment#set_endpoints(a,b)","text":"Unsafe. Set the endpoints of a segment shape. This change is only picked up as a change to the position of the shape's surface, but not its velocity. Changing it will not result in realistic physical behavior. Only use if you know what you are doing! [ View source ]","title":"#set_endpoints"},{"location":"shapes.html#CP::Shape::Segment#set_neighbors(prev,next)","text":"Let Chipmunk know about the geometry of adjacent segments to avoid colliding with endcaps. When you have a number of segment shapes that are all joined together, things can still collide with the \"cracks\" between the segments. By setting the neighbor segment endpoints you can tell Chipmunk to avoid colliding with the inner parts of the crack. [ View source ]","title":"#set_neighbors"},{"location":"shapes.html#CP::ShapeFilter","text":"Fast collision filtering type that is used to determine if two objects collide before calling collision or query callbacks. Chipmunk has two primary means of ignoring collisions: groups and category masks. Groups are used to ignore collisions between parts on a complex object. A ragdoll is a good example. When jointing an arm onto the torso, you'll want them to allow them to overlap. Groups allow you to do exactly that. Shapes that have the same group don't generate collisions. So by placing all of the shapes in a ragdoll in the same group, you'll prevent it from colliding against other parts of itself. Category masks allow you to mark which categories an object belongs to and which categories it collidies with. By default, objects exist in every category and collide with every category. The type of categories and mask in ShapeFilter is UInt32 . There is one last way of filtering collisions using collision handlers. See the section on callbacks for more information. Collision handlers can be more flexible, but can be slower. Fast collision filtering rejects collisions before running the expensive collision detection code, so using groups or category masks is preferred.","title":"ShapeFilter"},{"location":"shapes.html#constants","text":"","title":"Constants"},{"location":"shapes.html#CP::ShapeFilter::ALL","text":"Collision filter value for a shape that will collide with anything except NONE .","title":"ALL"},{"location":"shapes.html#CP::ShapeFilter::ALL_CATEGORIES","text":"Value for signifying that a shape is in every category.","title":"ALL_CATEGORIES"},{"location":"shapes.html#CP::ShapeFilter::NO_GROUP","text":"Value signifying that a shape is in no group.","title":"NO_GROUP"},{"location":"shapes.html#CP::ShapeFilter::NONE","text":"Collision filter value for a shape that does not collide with anything.","title":"NONE"},{"location":"shapes.html#class-methods_4","text":"","title":"Class methods"},{"location":"shapes.html#CP::ShapeFilter.new(group,categories,mask)","text":"[ View source ]","title":".new"},{"location":"shapes.html#methods_4","text":"","title":"Methods"},{"location":"shapes.html#CP::ShapeFilter#categories()","text":"A bitmask of user definable categories that this object belongs to. The category/mask combinations of both objects in a collision must agree for a collision to occur. [ View source ]","title":"#categories"},{"location":"shapes.html#CP::ShapeFilter#categories=(categories)","text":"[ View source ]","title":"#categories="},{"location":"shapes.html#CP::ShapeFilter#group()","text":"Two objects with the same non-zero group value do not collide. This is generally used to group objects in a composite object together to disable self collisions. [ View source ]","title":"#group"},{"location":"shapes.html#CP::ShapeFilter#group=(group)","text":"[ View source ]","title":"#group="},{"location":"shapes.html#CP::ShapeFilter#mask()","text":"A bitmask of user definable category types that this object object collides with. The category/mask combinations of both objects in a collision must agree for a collision to occur. [ View source ]","title":"#mask"},{"location":"shapes.html#CP::ShapeFilter#mask=(mask)","text":"[ View source ]","title":"#mask="},{"location":"shapes.html#CP::ShapeFilter::Bitmask","text":"","title":"Bitmask"},{"location":"shapes.html#alias-definition","text":"UInt32","title":"Alias definition"},{"location":"shapes.html#CP::ShapeFilter::Group","text":"","title":"Group"},{"location":"shapes.html#alias-definition_1","text":"UInt64","title":"Alias definition"},{"location":"space.html","text":"class CP::Space inherits Reference # Spaces are the basic unit of simulation. You add rigid bodies, shapes and joints to it and then step them all forward together through time. Class methods # .new ( * , threaded : Bool = true ) # [ View source ] Methods # #add ( body : Body ) : Body # Add a body to the simulation. If this method is called during a simulation step, the addition will be delayed until the step is finished. Returns the same Body , for convenience. [ View source ] #add ( * items : Shape | Body | Constraint ) # Add multiple items [ View source ] #add ( constraint : Constraint ) : Constraint # Add a constraint to the simulation. If this method is called during a simulation step, the addition will be delayed until the step is finished. Returns the same Constraint , for convenience. [ View source ] #add ( shape : Shape ) : Shape # Add a shape to the simulation. If the collision shape is attached to a static body, it will be added as a static shape. If this method is called during a simulation step, the addition will be delayed until the step is finished. Returns the same Shape , for convenience. [ View source ] #add_collision_handler ( a : Int , b : Int , handler : CollisionHandler ) : CollisionHandler # Whenever shapes with collision types a and b collide, this handler will be used to process the collision events. If wildcard handlers are used with either of the collision types, it's the responibility of the custom handler to invoke the wildcard handlers. [ View source ] #add_collision_handler ( type : Int , handler : CollisionHandler ) : CollisionHandler # Set a wildcard collision handler for the specified type. This handler will be used any time an object with this type collides with another object, regardless of its type. [ View source ] #add_collision_handler ( handler : CollisionHandler ) : CollisionHandler # Set a collision handler that is called for all collisions that are not handled by a more specific collision handler. [ View source ] #bb_query ( bb : BB , filter : ShapeFilter = ShapeFilter :: ALL ) : Array ( Shape ) # Perform a fast rectangle query on the space, yielding each shape found. Only the shapes' bounding boxes are checked for overlap, not their full shape. [ View source ] #bb_query ( bb : BB , filter : ShapeFilter = ShapeFilter :: ALL , & block : Shape -> ) # Perform a fast rectangle query on the space, yielding each shape found. Only the shapes' bounding boxes are checked for overlap, not their full shape. [ View source ] #collision_bias : Float64 # Determines how fast overlapping shapes are pushed apart. Expressed as a fraction of the error remaining after each second. Defaults to (1.0 - 0.1)**60.0 meaning that Chipmunk fixes 10% of overlap each frame at 60Hz. [ View source ] #collision_bias= ( collision_bias : Number ) # [ View source ] #collision_persistence : Timestamp # Number of frames that contact information should persist. Defaults to 3. There is probably never a reason to change this value. [ View source ] #collision_persistence= ( collision_persistence : Timestamp ) # [ View source ] #collision_slop : Float64 # Amount of encouraged penetration between colliding shapes. Used to reduce oscillating contacts and keep the collision cache warm. Defaults to 0.1. If you have poor simulation quality, increase this number as much as possible without allowing visible amounts of overlap. [ View source ] #collision_slop= ( collision_slop : Number ) # [ View source ] #contains? ( constraint : Constraint ) : Bool # Test if a constraint has been added to the space. [ View source ] #contains? ( shape : Shape ) : Bool # Test if a shape has been added to the space. [ View source ] #contains? ( body : Body ) : Bool # Test if a body has been added to the space. [ View source ] #current_time_step : Float64 # Returns the current (or most recent) time step used with the given space. Useful from callbacks if your time step is not a compile-time global. [ View source ] #damping : Float64 # Damping rate expressed as the fraction of velocity bodies retain each second. A value of 0.9 would mean that each body's velocity will drop 10% per second. The default value is 1.0, meaning no damping is applied. Note: This damping value is different than those of DampedSpring and DampedRotarySpring . [ View source ] #damping= ( damping : Number ) # [ View source ] #each_body ( & block : Body -> ) # Yield each body in the space. [ View source ] #each_constraint ( & block : Constraint -> ) # Yield each constraint in the space. [ View source ] #each_shape ( & block : Shape -> ) # Yield each shape in the space. [ View source ] #gravity : Vect # Gravity to pass to rigid bodies when integrating velocity. Defaults to (0,0). [ View source ] #gravity= ( gravity : Vect ) # [ View source ] #idle_speed_threshold : Float64 # Speed threshold for a body to be considered idle. The default value of 0 means to let the space guess a good threshold based on gravity. [ View source ] #idle_speed_threshold= ( idle_speed_threshold : Number ) # [ View source ] #iterations : Int32 # Number of iterations to use in the impulse solver to solve contacts and other constraints. Chipmunk uses an iterative solver to figure out the forces between objects in the space. What this means is that it builds a big list of all of the collisions, joints, and other constraints between the bodies and makes several passes over the list considering each one individually. The number of passes it makes is the iteration count, and each iteration makes the solution more accurate. If you use too many iterations, the physics should look nice and solid, but may use up too much CPU time. If you use too few iterations, the simulation may seem mushy or bouncy when the objects should be solid. Setting the number of iterations lets you balance between CPU usage and the accuracy of the physics. Chipmunk's default of 10 iterations is sufficient for most simple games. [ View source ] #iterations= ( iterations : Int ) # [ View source ] #locked? : Bool # Returns true from inside a callback when objects cannot be added/removed. [ View source ] #point_query ( point : Vect , max_distance : Number = 0 , filter : ShapeFilter = ShapeFilter :: ALL ) : Array ( PointQueryInfo ) # Query the space at a point for shapes within the given distance range. The filter is applied to the query and follows the same rules as the collision detection. Sensor shapes are included. If a max_distance of 0 is used, the point must lie inside a shape. Negative max_distance is also allowed meaning that the point must be a under a certain depth within a shape to be considered a match. [ View source ] #point_query ( point : Vect , max_distance : Number = 0 , filter : ShapeFilter = ShapeFilter :: ALL , & block : PointQueryInfo -> ) # Query the space at a point for shapes within the given distance range. The filter is applied to the query and follows the same rules as the collision detection. Sensor shapes are included. If a max_distance of 0 is used, the point must lie inside a shape. Negative max_distance is also allowed meaning that the point must be a under a certain depth within a shape to be considered a match. [ View source ] #point_query_nearest ( point : Vect , max_distance : Number = 0 , filter : ShapeFilter = ShapeFilter :: ALL ) : PointQueryInfo? # Query the space at a point and return the nearest shape found. Returns nil if no shapes were found. [ View source ] #reindex ( shape : Shape ) # Update the collision detection data for a specific shape in the space. [ View source ] #reindex_shapes_for ( body : Body ) # Update the collision detection data for all shapes attached to a body. [ View source ] #reindex_static # Update the collision detection info for the static shapes in the space. [ View source ] #remove ( * items : Shape | Body | Constraint ) # Remove multiple items [ View source ] #remove ( constraint : Constraint ) # Remove a constraint from the simulation. If this method is called during a simulation step, the removal will be delayed until the step is finished. [ View source ] #remove ( shape : Shape ) # Remove a shape from the simulation. If this method is called during a simulation step, the removal will be delayed until the step is finished. [ View source ] #remove ( body : Body ) # Remove a body from the simulation. If this method is called during a simulation step, the removal will be delayed until the step is finished. [ View source ] #segment_query ( start : Vect , end end_ : Vect , radius : Number = 0 , filter : ShapeFilter = ShapeFilter :: ALL , & block : SegmentQueryInfo -> ) # Perform a directed line segment query (like a raycast) against the space and yield each shape intersected. The filter is applied to the query and follows the same rules as the collision detection. Sensor shapes are included. [ View source ] #segment_query ( start : Vect , end end_ : Vect , radius : Number = 0 , filter : ShapeFilter = ShapeFilter :: ALL ) : Array ( SegmentQueryInfo ) # Perform a directed line segment query (like a raycast) against the space and yield each shape intersected. The filter is applied to the query and follows the same rules as the collision detection. Sensor shapes are included. [ View source ] #segment_query_first ( start : Vect , end end_ : Vect , radius : Number = 0 , filter : ShapeFilter = ShapeFilter :: ALL ) : SegmentQueryInfo? # Perform a directed line segment query (like a raycast) against the space and return the first shape hit. Returns nil if no shapes were hit. [ View source ] #shape_query ( shape : Shape , & block : Shape , ContactPointSet -> ) # Query a space for any shapes overlapping the given shape and yield each shape found. [ View source ] #shape_query ( shape : Shape ) : Array ( Shape ) # Query a space for any shapes overlapping the given shape and yield each shape found. [ View source ] #sleep_time_threshold : Float64 # Time a group of bodies must remain idle in order to fall asleep. Enabling sleeping also implicitly enables the the contact graph. The default value of INFINITY disables the sleeping algorithm. [ View source ] #sleep_time_threshold= ( sleep_time_threshold : Number ) # [ View source ] #static_body : Body # The Space provided static body for a given Space . This is merely provided for convenience and you are not required to use it. [ View source ] #step ( dt : Number ) # Step the space forward in time by dt seconds. [ View source ] #threads : Int # Returns number of threads for multithreaded physics solver or 0 if the space isn't hasty [ View source ] #threads= ( nthreads : Int ) # Set number of threads for multithreaded physics solver [ View source ] #use_spatial_hash ( dim : Number , count : Int ) # Switch the space to use a spatial has as its spatial index. [ View source ] alias CP::Space::Timestamp # Alias definition # UInt32","title":"Space"},{"location":"space.html#CP::Space","text":"Spaces are the basic unit of simulation. You add rigid bodies, shapes and joints to it and then step them all forward together through time.","title":"Space"},{"location":"space.html#class-methods","text":"","title":"Class methods"},{"location":"space.html#CP::Space.new(*,threaded)","text":"[ View source ]","title":".new"},{"location":"space.html#methods","text":"","title":"Methods"},{"location":"space.html#CP::Space#add(body)","text":"Add a body to the simulation. If this method is called during a simulation step, the addition will be delayed until the step is finished. Returns the same Body , for convenience. [ View source ]","title":"#add"},{"location":"space.html#CP::Space#add_collision_handler(a,b,handler)","text":"Whenever shapes with collision types a and b collide, this handler will be used to process the collision events. If wildcard handlers are used with either of the collision types, it's the responibility of the custom handler to invoke the wildcard handlers. [ View source ]","title":"#add_collision_handler"},{"location":"space.html#CP::Space#bb_query(bb,filter)","text":"Perform a fast rectangle query on the space, yielding each shape found. Only the shapes' bounding boxes are checked for overlap, not their full shape. [ View source ]","title":"#bb_query"},{"location":"space.html#CP::Space#collision_bias()","text":"Determines how fast overlapping shapes are pushed apart. Expressed as a fraction of the error remaining after each second. Defaults to (1.0 - 0.1)**60.0 meaning that Chipmunk fixes 10% of overlap each frame at 60Hz. [ View source ]","title":"#collision_bias"},{"location":"space.html#CP::Space#collision_bias=(collision_bias)","text":"[ View source ]","title":"#collision_bias="},{"location":"space.html#CP::Space#collision_persistence()","text":"Number of frames that contact information should persist. Defaults to 3. There is probably never a reason to change this value. [ View source ]","title":"#collision_persistence"},{"location":"space.html#CP::Space#collision_persistence=(collision_persistence)","text":"[ View source ]","title":"#collision_persistence="},{"location":"space.html#CP::Space#collision_slop()","text":"Amount of encouraged penetration between colliding shapes. Used to reduce oscillating contacts and keep the collision cache warm. Defaults to 0.1. If you have poor simulation quality, increase this number as much as possible without allowing visible amounts of overlap. [ View source ]","title":"#collision_slop"},{"location":"space.html#CP::Space#collision_slop=(collision_slop)","text":"[ View source ]","title":"#collision_slop="},{"location":"space.html#CP::Space#contains?(constraint)","text":"Test if a constraint has been added to the space. [ View source ]","title":"#contains?"},{"location":"space.html#CP::Space#current_time_step()","text":"Returns the current (or most recent) time step used with the given space. Useful from callbacks if your time step is not a compile-time global. [ View source ]","title":"#current_time_step"},{"location":"space.html#CP::Space#damping()","text":"Damping rate expressed as the fraction of velocity bodies retain each second. A value of 0.9 would mean that each body's velocity will drop 10% per second. The default value is 1.0, meaning no damping is applied. Note: This damping value is different than those of DampedSpring and DampedRotarySpring . [ View source ]","title":"#damping"},{"location":"space.html#CP::Space#damping=(damping)","text":"[ View source ]","title":"#damping="},{"location":"space.html#CP::Space#each_body(&)","text":"Yield each body in the space. [ View source ]","title":"#each_body"},{"location":"space.html#CP::Space#each_constraint(&)","text":"Yield each constraint in the space. [ View source ]","title":"#each_constraint"},{"location":"space.html#CP::Space#each_shape(&)","text":"Yield each shape in the space. [ View source ]","title":"#each_shape"},{"location":"space.html#CP::Space#gravity()","text":"Gravity to pass to rigid bodies when integrating velocity. Defaults to (0,0). [ View source ]","title":"#gravity"},{"location":"space.html#CP::Space#gravity=(gravity)","text":"[ View source ]","title":"#gravity="},{"location":"space.html#CP::Space#idle_speed_threshold()","text":"Speed threshold for a body to be considered idle. The default value of 0 means to let the space guess a good threshold based on gravity. [ View source ]","title":"#idle_speed_threshold"},{"location":"space.html#CP::Space#idle_speed_threshold=(idle_speed_threshold)","text":"[ View source ]","title":"#idle_speed_threshold="},{"location":"space.html#CP::Space#iterations()","text":"Number of iterations to use in the impulse solver to solve contacts and other constraints. Chipmunk uses an iterative solver to figure out the forces between objects in the space. What this means is that it builds a big list of all of the collisions, joints, and other constraints between the bodies and makes several passes over the list considering each one individually. The number of passes it makes is the iteration count, and each iteration makes the solution more accurate. If you use too many iterations, the physics should look nice and solid, but may use up too much CPU time. If you use too few iterations, the simulation may seem mushy or bouncy when the objects should be solid. Setting the number of iterations lets you balance between CPU usage and the accuracy of the physics. Chipmunk's default of 10 iterations is sufficient for most simple games. [ View source ]","title":"#iterations"},{"location":"space.html#CP::Space#iterations=(iterations)","text":"[ View source ]","title":"#iterations="},{"location":"space.html#CP::Space#locked?()","text":"Returns true from inside a callback when objects cannot be added/removed. [ View source ]","title":"#locked?"},{"location":"space.html#CP::Space#point_query(point,max_distance,filter)","text":"Query the space at a point for shapes within the given distance range. The filter is applied to the query and follows the same rules as the collision detection. Sensor shapes are included. If a max_distance of 0 is used, the point must lie inside a shape. Negative max_distance is also allowed meaning that the point must be a under a certain depth within a shape to be considered a match. [ View source ]","title":"#point_query"},{"location":"space.html#CP::Space#point_query_nearest(point,max_distance,filter)","text":"Query the space at a point and return the nearest shape found. Returns nil if no shapes were found. [ View source ]","title":"#point_query_nearest"},{"location":"space.html#CP::Space#reindex(shape)","text":"Update the collision detection data for a specific shape in the space. [ View source ]","title":"#reindex"},{"location":"space.html#CP::Space#reindex_shapes_for(body)","text":"Update the collision detection data for all shapes attached to a body. [ View source ]","title":"#reindex_shapes_for"},{"location":"space.html#CP::Space#reindex_static()","text":"Update the collision detection info for the static shapes in the space. [ View source ]","title":"#reindex_static"},{"location":"space.html#CP::Space#remove(*items)","text":"Remove multiple items [ View source ]","title":"#remove"},{"location":"space.html#CP::Space#segment_query(start,end,radius,filter,&)","text":"Perform a directed line segment query (like a raycast) against the space and yield each shape intersected. The filter is applied to the query and follows the same rules as the collision detection. Sensor shapes are included. [ View source ]","title":"#segment_query"},{"location":"space.html#CP::Space#segment_query_first(start,end,radius,filter)","text":"Perform a directed line segment query (like a raycast) against the space and return the first shape hit. Returns nil if no shapes were hit. [ View source ]","title":"#segment_query_first"},{"location":"space.html#CP::Space#shape_query(shape,&)","text":"Query a space for any shapes overlapping the given shape and yield each shape found. [ View source ]","title":"#shape_query"},{"location":"space.html#CP::Space#sleep_time_threshold()","text":"Time a group of bodies must remain idle in order to fall asleep. Enabling sleeping also implicitly enables the the contact graph. The default value of INFINITY disables the sleeping algorithm. [ View source ]","title":"#sleep_time_threshold"},{"location":"space.html#CP::Space#sleep_time_threshold=(sleep_time_threshold)","text":"[ View source ]","title":"#sleep_time_threshold="},{"location":"space.html#CP::Space#static_body()","text":"The Space provided static body for a given Space . This is merely provided for convenience and you are not required to use it. [ View source ]","title":"#static_body"},{"location":"space.html#CP::Space#step(dt)","text":"Step the space forward in time by dt seconds. [ View source ]","title":"#step"},{"location":"space.html#CP::Space#threads()","text":"Returns number of threads for multithreaded physics solver or 0 if the space isn't hasty [ View source ]","title":"#threads"},{"location":"space.html#CP::Space#threads=(nthreads)","text":"Set number of threads for multithreaded physics solver [ View source ]","title":"#threads="},{"location":"space.html#CP::Space#use_spatial_hash(dim,count)","text":"Switch the space to use a spatial has as its spatial index. [ View source ]","title":"#use_spatial_hash"},{"location":"space.html#CP::Space::Timestamp","text":"","title":"Timestamp"},{"location":"space.html#alias-definition","text":"UInt32","title":"Alias definition"},{"location":"vector-math.html","text":"module CP # Extended modules # CP Methods # #lerp ( f1 : Number , f2 : Number , t : Number ) : Number # Linearly interpolate (or extrapolate) between f1 and f2 by t percent. [ View source ] #lerpconst ( f1 : Number , f2 : Number , d : Number ) : Number # Linearly interpolate from f1 to f2 by no more than d . [ View source ] #v ( x , y ) : Vect # Convenience function to create a Vect . [ View source ] #vzero : Vect # Zero Vect . [ View source ] struct CP::Vect inherits Struct # Chipmunk's 2D vector type. Class methods # .angle ( a : Number ) : self # Returns the unit length vector for the given angle (in radians). [ View source ] .lerp ( v1 : Vect , v2 : Vect , t : Number ) : Vect # Linearly interpolate between v1 and v2 . [ View source ] .lerpconst ( v1 : Vect , v2 : Vect , d : Number ) : Vect # Linearly interpolate between v1 towards v2 by distance d . [ View source ] .new ( x : Number , y : Number ) # [ View source ] .slerp ( v1 : Vect , v2 : Vect , t : Number ) : Vect # Spherical linearly interpolate between v1 and v2 . [ View source ] .slerpconst ( v1 : Vect , v2 : Vect , a : Number ) : Vect # Spherical linearly interpolate between v1 towards v2 by no more than angle a radians [ View source ] Methods # #* ( s : Number ) : Vect # Scalar multiplication. [ View source ] #+ ( v2 : Vect ) : Vect # Add two vectors [ View source ] #- ( v2 : Vect ) : Vect # Subtract two vectors. [ View source ] #- : Vect # Negate a vector. [ View source ] #== ( v2 : Vect ) : Bool # Check if two vectors are equal. (Be careful when comparing floating point numbers!) [ View source ] #clamp ( len : Number ) : Vect # Clamp the vector to length len. [ View source ] #closest_point_on_segment ( a : Vect , b : Vect ) : Vect # Returns the closest point on the line segment a b , to the point stored in this Vect . [ View source ] #cross ( v2 : Vect ) : Float64 # 2D vector cross product analog. The cross product of 2D vectors results in a 3D vector with only a z component. This function returns the magnitude of the z value. [ View source ] #dist ( v2 : Vect ) : Float64 # Returns the distance between this vector and v2 . [ View source ] #distsq ( v2 : Vect ) : Float64 # Returns the squared distance between this vector and v2 . Faster than dist when you only need to compare distances. [ View source ] #dot ( v2 : Vect ) : Float64 # Vector dot product. [ View source ] #length : Float64 # Returns the length of the vector. [ View source ] #lengthsq : Float64 # Returns the squared length of the vector. Faster than length when you only need to compare lengths. [ View source ] #near? ( v2 : Vect , dist : Number ) : Bool # Returns true if the distance between this vector and v2 is less than dist . [ View source ] #normalize : Vect # Returns a normalized copy of the vector (unit vector). [ View source ] #perp : Vect # Returns a perpendicular vector. (90 degree rotation) [ View source ] #project ( v2 : Vect ) : Vect # Returns the vector projection of the vector onto v2 . [ View source ] #rotate ( v2 : Vect ) : Vect # Uses complex number multiplication to rotate the vector by v2 . Scaling will occur if the vector is not a unit vector. [ View source ] #rperp : Vect # Returns a perpendicular vector. (-90 degree rotation) [ View source ] #to_angle : Float64 # Returns the angular direction the vector is pointing in (in radians). [ View source ] #unrotate ( v2 : Vect ) : Vect # Inverse of rotate . [ View source ] #x : Float64 # [ View source ] #x= ( x : Float64 ) # [ View source ] #y : Float64 # [ View source ] #y= ( y : Float64 ) # [ View source ] struct CP::BB inherits Struct # Chipmunk's axis-aligned 2D bounding box type. (left, bottom, right, top) Class methods # .new ( left : Number = 0 , bottom : Number = 0 , right : Number = 0 , top : Number = 0 ) # [ View source ] .new_for_circle ( p : Vect , r : Number ) : self # Constructs a BB fitting a circle with the position p and radius r . [ View source ] .new_for_extents ( c : Vect , hw : Number , hh : Number ) : self # Constructs a BB centered on a point with the given extents (half sizes). [ View source ] Methods # #area : Float64 # Returns the area of the bounding box. [ View source ] #bottom : Float64 # [ View source ] #bottom= ( bottom : Float64 ) # [ View source ] #center : Vect # Returns the center of a bounding box. [ View source ] #clamp_vect ( v : Vect ) : Vect # Clamp a vector to a bounding box [ View source ] #contains? ( point : Vect ) : Bool # Returns true if this BB contains the point . [ View source ] #contains? ( other : BB ) : Bool # Returns true if the other BB lies completely within this one. [ View source ] #expand ( point : Vect ) : BB # Returns the minimal bounding box that contains both this BB and the point . [ View source ] #intersects? ( other : BB ) : Bool # Returns true if this BB intersects the other . [ View source ] #intersects_segment? ( a : Vect , b : Vect ) : Bool # Return true if the bounding box intersects the line segment with ends a and b . [ View source ] #left : Float64 # [ View source ] #left= ( left : Float64 ) # [ View source ] #merge ( other : BB ) : BB # Returns a bounding box that holds both bounding boxes. [ View source ] #offset ( v : Vect ) : BB # Returns a bounding box offseted by v . [ View source ] #right : Float64 # [ View source ] #right= ( right : Float64 ) # [ View source ] #segment_query ( a : Vect , b : Vect ) : Float64 # Returns the fraction along the segment query the BB is hit. Returns INFINITY if it doesn't hit. [ View source ] #top : Float64 # [ View source ] #top= ( top : Float64 ) # [ View source ] #wrap_vect ( v : Vect ) : Vect # Wrap a vector to a bounding box. [ View source ] struct CP::Mat2x2 inherits Struct # 2x2 matrix type used for tensors and such. (row major: [[a b][c d]] ) Class methods # .new ( a : Number , b : Number , c : Number , d : Number ) # [ View source ] Methods # #a : Float64 # [ View source ] #a= ( a : Float64 ) # [ View source ] #b : Float64 # [ View source ] #b= ( b : Float64 ) # [ View source ] #c : Float64 # [ View source ] #c= ( c : Float64 ) # [ View source ] #d : Float64 # [ View source ] #d= ( d : Float64 ) # [ View source ] #transform ( v : Vect ) : Vect # [ View source ] struct CP::Transform inherits Struct # Column major 2x3 affine transform. Constants # IDENTITY # Identity transform matrix. Class methods # .axial_scale ( axis : Vect , pivot : Vect , scale : Number ) : self # [ View source ] .bone_scale ( v0 : Vect , v1 : Vect ) : self # [ View source ] .new ( a : Number = 1 , b : Number = 0 , c : Number = 0 , d : Number = 1 , tx : Number = 0 , ty : Number = 0 ) # Construct a new transform matrix. ( a , b ) is the x basis vector. ( c , d ) is the y basis vector. ( tx , ty ) is the translation. [ View source ] .new_transpose ( a : Number , c : Number , tx : Number , b : Number , d : Number , ty : Number ) : self # Construct a new transform matrix in transposed order. [ View source ] .ortho ( bb : BB ) : self # [ View source ] .rigid ( translate : Vect , radians : Number ) : Transform # Create a rigid transformation matrix. (translation + rotation) [ View source ] .rigid_inverse : Transform # Fast inverse of a rigid transformation matrix. [ View source ] .rotate ( radians : Number ) : self # Create a rotation matrix. [ View source ] .scale ( scale_x : Number , scale_y : Number ) : self # Create a scale matrix. [ View source ] .translate ( translate : Vect ) : self # Create a translation matrix. [ View source ] Methods # #* ( t2 : Transform ) : Transform # Multiply two transformation matrices. [ View source ] #a : Float64 # [ View source ] #a= ( a : Float64 ) # [ View source ] #b : Float64 # [ View source ] #b= ( b : Float64 ) # [ View source ] #c : Float64 # [ View source ] #c= ( c : Float64 ) # [ View source ] #d : Float64 # [ View source ] #d= ( d : Float64 ) # [ View source ] #inverse : Transform # Get the inverse of a transform matrix. [ View source ] #transform ( bb : BB ) : BB # Transform a BB . [ View source ] #transform_point ( p : Vect ) : Vect # Transform an absolute point. (i.e. a vertex) [ View source ] #transform_vect ( v : Vect ) : Vect # Transform a vector (i.e. a normal) [ View source ] #tx : Float64 # [ View source ] #tx= ( tx : Float64 ) # [ View source ] #ty : Float64 # [ View source ] #ty= ( ty : Float64 ) # [ View source ] #wrap ( inner : Transform ) : Transform # [ View source ] #wrap_inverse ( inner : Transform ) : Transform # [ View source ]","title":"Vector math"},{"location":"vector-math.html#CP","text":"","title":"CP"},{"location":"vector-math.html#extended-modules","text":"CP","title":"Extended modules"},{"location":"vector-math.html#methods","text":"","title":"Methods"},{"location":"vector-math.html#CP#lerp(f1,f2,t)","text":"Linearly interpolate (or extrapolate) between f1 and f2 by t percent. [ View source ]","title":"#lerp"},{"location":"vector-math.html#CP#lerpconst(f1,f2,d)","text":"Linearly interpolate from f1 to f2 by no more than d . [ View source ]","title":"#lerpconst"},{"location":"vector-math.html#CP#v(x,y)","text":"Convenience function to create a Vect . [ View source ]","title":"#v"},{"location":"vector-math.html#CP#vzero()","text":"Zero Vect . [ View source ]","title":"#vzero"},{"location":"vector-math.html#CP::Vect","text":"Chipmunk's 2D vector type.","title":"Vect"},{"location":"vector-math.html#class-methods","text":"","title":"Class methods"},{"location":"vector-math.html#CP::Vect.angle(a)","text":"Returns the unit length vector for the given angle (in radians). [ View source ]","title":".angle"},{"location":"vector-math.html#CP::Vect.lerp(v1,v2,t)","text":"Linearly interpolate between v1 and v2 . [ View source ]","title":".lerp"},{"location":"vector-math.html#CP::Vect.lerpconst(v1,v2,d)","text":"Linearly interpolate between v1 towards v2 by distance d . [ View source ]","title":".lerpconst"},{"location":"vector-math.html#CP::Vect.new(x,y)","text":"[ View source ]","title":".new"},{"location":"vector-math.html#CP::Vect.slerp(v1,v2,t)","text":"Spherical linearly interpolate between v1 and v2 . [ View source ]","title":".slerp"},{"location":"vector-math.html#CP::Vect.slerpconst(v1,v2,a)","text":"Spherical linearly interpolate between v1 towards v2 by no more than angle a radians [ View source ]","title":".slerpconst"},{"location":"vector-math.html#methods_1","text":"","title":"Methods"},{"location":"vector-math.html#CP::Vect#*(s)","text":"Scalar multiplication. [ View source ]","title":"#*"},{"location":"vector-math.html#CP::Vect#+(v2)","text":"Add two vectors [ View source ]","title":"#+"},{"location":"vector-math.html#CP::Vect#-(v2)","text":"Subtract two vectors. [ View source ]","title":"#-"},{"location":"vector-math.html#CP::Vect#==(v2)","text":"Check if two vectors are equal. (Be careful when comparing floating point numbers!) [ View source ]","title":"#=="},{"location":"vector-math.html#CP::Vect#clamp(len)","text":"Clamp the vector to length len. [ View source ]","title":"#clamp"},{"location":"vector-math.html#CP::Vect#closest_point_on_segment(a,b)","text":"Returns the closest point on the line segment a b , to the point stored in this Vect . [ View source ]","title":"#closest_point_on_segment"},{"location":"vector-math.html#CP::Vect#cross(v2)","text":"2D vector cross product analog. The cross product of 2D vectors results in a 3D vector with only a z component. This function returns the magnitude of the z value. [ View source ]","title":"#cross"},{"location":"vector-math.html#CP::Vect#dist(v2)","text":"Returns the distance between this vector and v2 . [ View source ]","title":"#dist"},{"location":"vector-math.html#CP::Vect#distsq(v2)","text":"Returns the squared distance between this vector and v2 . Faster than dist when you only need to compare distances. [ View source ]","title":"#distsq"},{"location":"vector-math.html#CP::Vect#dot(v2)","text":"Vector dot product. [ View source ]","title":"#dot"},{"location":"vector-math.html#CP::Vect#length()","text":"Returns the length of the vector. [ View source ]","title":"#length"},{"location":"vector-math.html#CP::Vect#lengthsq()","text":"Returns the squared length of the vector. Faster than length when you only need to compare lengths. [ View source ]","title":"#lengthsq"},{"location":"vector-math.html#CP::Vect#near?(v2,dist)","text":"Returns true if the distance between this vector and v2 is less than dist . [ View source ]","title":"#near?"},{"location":"vector-math.html#CP::Vect#normalize()","text":"Returns a normalized copy of the vector (unit vector). [ View source ]","title":"#normalize"},{"location":"vector-math.html#CP::Vect#perp()","text":"Returns a perpendicular vector. (90 degree rotation) [ View source ]","title":"#perp"},{"location":"vector-math.html#CP::Vect#project(v2)","text":"Returns the vector projection of the vector onto v2 . [ View source ]","title":"#project"},{"location":"vector-math.html#CP::Vect#rotate(v2)","text":"Uses complex number multiplication to rotate the vector by v2 . Scaling will occur if the vector is not a unit vector. [ View source ]","title":"#rotate"},{"location":"vector-math.html#CP::Vect#rperp()","text":"Returns a perpendicular vector. (-90 degree rotation) [ View source ]","title":"#rperp"},{"location":"vector-math.html#CP::Vect#to_angle()","text":"Returns the angular direction the vector is pointing in (in radians). [ View source ]","title":"#to_angle"},{"location":"vector-math.html#CP::Vect#unrotate(v2)","text":"Inverse of rotate . [ View source ]","title":"#unrotate"},{"location":"vector-math.html#CP::Vect#x()","text":"[ View source ]","title":"#x"},{"location":"vector-math.html#CP::Vect#x=(x)","text":"[ View source ]","title":"#x="},{"location":"vector-math.html#CP::Vect#y()","text":"[ View source ]","title":"#y"},{"location":"vector-math.html#CP::Vect#y=(y)","text":"[ View source ]","title":"#y="},{"location":"vector-math.html#CP::BB","text":"Chipmunk's axis-aligned 2D bounding box type. (left, bottom, right, top)","title":"BB"},{"location":"vector-math.html#class-methods_1","text":"","title":"Class methods"},{"location":"vector-math.html#CP::BB.new(left,bottom,right,top)","text":"[ View source ]","title":".new"},{"location":"vector-math.html#CP::BB.new_for_circle(p,r)","text":"Constructs a BB fitting a circle with the position p and radius r . [ View source ]","title":".new_for_circle"},{"location":"vector-math.html#CP::BB.new_for_extents(c,hw,hh)","text":"Constructs a BB centered on a point with the given extents (half sizes). [ View source ]","title":".new_for_extents"},{"location":"vector-math.html#methods_2","text":"","title":"Methods"},{"location":"vector-math.html#CP::BB#area()","text":"Returns the area of the bounding box. [ View source ]","title":"#area"},{"location":"vector-math.html#CP::BB#bottom()","text":"[ View source ]","title":"#bottom"},{"location":"vector-math.html#CP::BB#bottom=(bottom)","text":"[ View source ]","title":"#bottom="},{"location":"vector-math.html#CP::BB#center()","text":"Returns the center of a bounding box. [ View source ]","title":"#center"},{"location":"vector-math.html#CP::BB#clamp_vect(v)","text":"Clamp a vector to a bounding box [ View source ]","title":"#clamp_vect"},{"location":"vector-math.html#CP::BB#contains?(point)","text":"Returns true if this BB contains the point . [ View source ]","title":"#contains?"},{"location":"vector-math.html#CP::BB#expand(point)","text":"Returns the minimal bounding box that contains both this BB and the point . [ View source ]","title":"#expand"},{"location":"vector-math.html#CP::BB#intersects?(other)","text":"Returns true if this BB intersects the other . [ View source ]","title":"#intersects?"},{"location":"vector-math.html#CP::BB#intersects_segment?(a,b)","text":"Return true if the bounding box intersects the line segment with ends a and b . [ View source ]","title":"#intersects_segment?"},{"location":"vector-math.html#CP::BB#left()","text":"[ View source ]","title":"#left"},{"location":"vector-math.html#CP::BB#left=(left)","text":"[ View source ]","title":"#left="},{"location":"vector-math.html#CP::BB#merge(other)","text":"Returns a bounding box that holds both bounding boxes. [ View source ]","title":"#merge"},{"location":"vector-math.html#CP::BB#offset(v)","text":"Returns a bounding box offseted by v . [ View source ]","title":"#offset"},{"location":"vector-math.html#CP::BB#right()","text":"[ View source ]","title":"#right"},{"location":"vector-math.html#CP::BB#right=(right)","text":"[ View source ]","title":"#right="},{"location":"vector-math.html#CP::BB#segment_query(a,b)","text":"Returns the fraction along the segment query the BB is hit. Returns INFINITY if it doesn't hit. [ View source ]","title":"#segment_query"},{"location":"vector-math.html#CP::BB#top()","text":"[ View source ]","title":"#top"},{"location":"vector-math.html#CP::BB#top=(top)","text":"[ View source ]","title":"#top="},{"location":"vector-math.html#CP::BB#wrap_vect(v)","text":"Wrap a vector to a bounding box. [ View source ]","title":"#wrap_vect"},{"location":"vector-math.html#CP::Mat2x2","text":"2x2 matrix type used for tensors and such. (row major: [[a b][c d]] )","title":"Mat2x2"},{"location":"vector-math.html#class-methods_2","text":"","title":"Class methods"},{"location":"vector-math.html#CP::Mat2x2.new(a,b,c,d)","text":"[ View source ]","title":".new"},{"location":"vector-math.html#methods_3","text":"","title":"Methods"},{"location":"vector-math.html#CP::Mat2x2#a()","text":"[ View source ]","title":"#a"},{"location":"vector-math.html#CP::Mat2x2#a=(a)","text":"[ View source ]","title":"#a="},{"location":"vector-math.html#CP::Mat2x2#b()","text":"[ View source ]","title":"#b"},{"location":"vector-math.html#CP::Mat2x2#b=(b)","text":"[ View source ]","title":"#b="},{"location":"vector-math.html#CP::Mat2x2#c()","text":"[ View source ]","title":"#c"},{"location":"vector-math.html#CP::Mat2x2#c=(c)","text":"[ View source ]","title":"#c="},{"location":"vector-math.html#CP::Mat2x2#d()","text":"[ View source ]","title":"#d"},{"location":"vector-math.html#CP::Mat2x2#d=(d)","text":"[ View source ]","title":"#d="},{"location":"vector-math.html#CP::Mat2x2#transform(v)","text":"[ View source ]","title":"#transform"},{"location":"vector-math.html#CP::Transform","text":"Column major 2x3 affine transform.","title":"Transform"},{"location":"vector-math.html#constants","text":"","title":"Constants"},{"location":"vector-math.html#CP::Transform::IDENTITY","text":"Identity transform matrix.","title":"IDENTITY"},{"location":"vector-math.html#class-methods_3","text":"","title":"Class methods"},{"location":"vector-math.html#CP::Transform.axial_scale(axis,pivot,scale)","text":"[ View source ]","title":".axial_scale"},{"location":"vector-math.html#CP::Transform.bone_scale(v0,v1)","text":"[ View source ]","title":".bone_scale"},{"location":"vector-math.html#CP::Transform.new(a,b,c,d,tx,ty)","text":"Construct a new transform matrix. ( a , b ) is the x basis vector. ( c , d ) is the y basis vector. ( tx , ty ) is the translation. [ View source ]","title":".new"},{"location":"vector-math.html#CP::Transform.new_transpose(a,c,tx,b,d,ty)","text":"Construct a new transform matrix in transposed order. [ View source ]","title":".new_transpose"},{"location":"vector-math.html#CP::Transform.ortho(bb)","text":"[ View source ]","title":".ortho"},{"location":"vector-math.html#CP::Transform.rigid(translate,radians)","text":"Create a rigid transformation matrix. (translation + rotation) [ View source ]","title":".rigid"},{"location":"vector-math.html#CP::Transform.rigid_inverse()","text":"Fast inverse of a rigid transformation matrix. [ View source ]","title":".rigid_inverse"},{"location":"vector-math.html#CP::Transform.rotate(radians)","text":"Create a rotation matrix. [ View source ]","title":".rotate"},{"location":"vector-math.html#CP::Transform.scale(scale_x,scale_y)","text":"Create a scale matrix. [ View source ]","title":".scale"},{"location":"vector-math.html#CP::Transform.translate(translate)","text":"Create a translation matrix. [ View source ]","title":".translate"},{"location":"vector-math.html#methods_4","text":"","title":"Methods"},{"location":"vector-math.html#CP::Transform#*(t2)","text":"Multiply two transformation matrices. [ View source ]","title":"#*"},{"location":"vector-math.html#CP::Transform#a()","text":"[ View source ]","title":"#a"},{"location":"vector-math.html#CP::Transform#a=(a)","text":"[ View source ]","title":"#a="},{"location":"vector-math.html#CP::Transform#b()","text":"[ View source ]","title":"#b"},{"location":"vector-math.html#CP::Transform#b=(b)","text":"[ View source ]","title":"#b="},{"location":"vector-math.html#CP::Transform#c()","text":"[ View source ]","title":"#c"},{"location":"vector-math.html#CP::Transform#c=(c)","text":"[ View source ]","title":"#c="},{"location":"vector-math.html#CP::Transform#d()","text":"[ View source ]","title":"#d"},{"location":"vector-math.html#CP::Transform#d=(d)","text":"[ View source ]","title":"#d="},{"location":"vector-math.html#CP::Transform#inverse()","text":"Get the inverse of a transform matrix. [ View source ]","title":"#inverse"},{"location":"vector-math.html#CP::Transform#transform(bb)","text":"Transform a BB . [ View source ]","title":"#transform"},{"location":"vector-math.html#CP::Transform#transform_point(p)","text":"Transform an absolute point. (i.e. a vertex) [ View source ]","title":"#transform_point"},{"location":"vector-math.html#CP::Transform#transform_vect(v)","text":"Transform a vector (i.e. a normal) [ View source ]","title":"#transform_vect"},{"location":"vector-math.html#CP::Transform#tx()","text":"[ View source ]","title":"#tx"},{"location":"vector-math.html#CP::Transform#tx=(tx)","text":"[ View source ]","title":"#tx="},{"location":"vector-math.html#CP::Transform#ty()","text":"[ View source ]","title":"#ty"},{"location":"vector-math.html#CP::Transform#ty=(ty)","text":"[ View source ]","title":"#ty="},{"location":"vector-math.html#CP::Transform#wrap(inner)","text":"[ View source ]","title":"#wrap"},{"location":"vector-math.html#CP::Transform#wrap_inverse(inner)","text":"[ View source ]","title":"#wrap_inverse"}]}